<!--
```agda
open import 1Lab.Path.Reasoning
open import 1Lab.Prelude

open import Algebra.Group.Cat.FinitelyComplete
open import Algebra.Group.Instances.Integers
open import Algebra.Group.Cat.Base
open import Algebra.Group.Homotopy
open import Algebra.Group

open import Data.Set.Truncation
open import Data.Int.Universal
open import Data.Bool
open import Data.Int
```
-->

```agda
module Homotopy.Space.Circle where
```

<!--
```agda
private variable
  ℓ ℓ' : Level
  X : Type ℓ
```
-->

# Spaces: The circle {defines="circle"}

The first example of nontrivial space one typically encounters when
studying synthetic homotopy theory is the circle: it is, in a sense, the
perfect space to start with, having exactly one nontrivial path space,
which is a [[free group|free group construction]], and the simplest
nontrivial [[free group|free group construction]] at that: the integers.

```agda
data S¹ : Type where
  base : S¹
  loop : base ≡ base

S¹∙ : Type∙ lzero
S¹∙ = S¹ , base
```

Diagrammatically, we can picture the circle as being the
$\infty$-groupoid generated by the following diagram:

~~~{.quiver}
\begin{tikzpicture}
\node[draw,circle,label=below:{$\rm{base}$},fill,outer sep=0.1cm, inner sep=0pt, minimum size=0.1cm] (a0) at (0, -1) {};
\draw[->] (0, 0) circle (1cm);
\node[] (loop) at (0, 0) {$\rm{loop}\ i$};
\end{tikzpicture}
~~~

In type theory with K, the circle is exactly the same type as
`⊤`{.Agda}. However, with `univalence`{.Agda ident=ua}, it can be shown
that the circle has at least two different paths:

<!--
```agda
_ = ⊤
```
-->

```agda
möbius : S¹ → Type
möbius base = Bool
möbius (loop i) = ua not≃ i
```

When pattern matching on the circle, we are asked to provide a basepoint
`b` and a path `l : b ≡ b`, as can be seen in the definition above. To
make it clearer, we can also define a recursion principle:

```agda
S¹-rec : ∀ {ℓ} {A : Type ℓ} (b : A) (l : b ≡ b) → S¹ → A
S¹-rec b l base     = b
S¹-rec b l (loop i) = l i
```

<!--
```agda
S¹-elim : ∀ {ℓ} {A : S¹ → Type ℓ} (b : A base) (l : PathP (λ i → A (loop i)) b b)
        → ∀ s → A s
S¹-elim b l base     = b
S¹-elim b l (loop i) = l i
```
-->

We call the map `möbius`{.Agda} a _double cover_ of the circle, since
the fibre at each point is a discrete space with two elements. It has an
action by the fundamental group of the circle, which has the effect of
negating the "parity" of the path. In fact, we can use `möbius`{.Agda}
to show that `loop`{.Agda} is not `refl`{.Agda}:

```agda
parity : base ≡ base → Bool
parity l = subst möbius l true

_ : parity refl ≡ true
_ = refl

_ : parity loop ≡ false
_ = refl

refl≠loop : ¬ refl ≡ loop
refl≠loop path = true≠false (ap parity path)
```

The circle is also useful as a source of counterexamples: we can prove that there
is an inhabitant of `(x : S¹) → x ≡ x`{.Agda} which is not constantly `refl`{.Agda}.

```agda
always-loop : (x : S¹) → x ≡ x
always-loop = S¹-elim loop (double-connection loop loop)
```

## Fundamental group {defines="loop-space-of-the-circle"}

We will now calculate that the first [[loop space]] of the circle at the
basepoint is *a* type of integers, i.e. it satisfies the [[universal
property of the integers]]. First, we generalise the construction of
`möbius`{.Agda} to turn equivalence on an arbitrary type into a type
family over `S¹`{.Agda}. Transport over this family will be the
universal map $\Omega S^1 \to X$ associated with an equivalence $e : X
\simeq X$ and basepoint $x_0 : X$.

```agda
equiv→family : X ≃ X → S¹ → Type _
equiv→family {X = X} eqv base = X
equiv→family eqv (loop i)     = ua eqv i
```

We will later need the "action" associated with an equivalence valued at
a path with free endpoint $y : S^1$. Taking $y = \rm{base}$ recovers a
more vanilla notion of "action on $X$".

```agda
equiv→action : ∀ {y} (e : X ≃ X) → base ≡ y → X → equiv→family e y
equiv→action e p x = subst (equiv→family e) p x

_ : X ≃ X → base ≡ base → X → X
_ = equiv→action {y = base}
```

<!--
```agda
open Integers
interleaved mutual
```
-->

The first thing we will do is assume an elimination principle for
$\Omega S^1$, which will be used in showing uniqueness of the universal
map $\Omega S^1 \to X$ associated to an equivalence $e : X \simeq X$.
We must also equip $\Omega S^1$ with an auto-equivalence, which
corresponds in some way to taking successors: since `loop`{.Agda}
corresponds to "the number 1", the equivalence we go with is thus
"adding 1": postcomposition with the `loop`{.Agda}.

```agda
  ΩS¹-elim
    : ∀ {ℓ} (P : Path S¹ base base → Type ℓ)
    → (pr : P refl)
    → (pl : P ≃[ ∙-post-equiv loop ] P)
    → ∀ x → P x

  private
    rotΩS¹ : (base ≡ base) ≃ (base ≡ base)
    rotΩS¹ = ∙-post-equiv {x = base} loop

  ΩS¹-integers : Integers (Path S¹ base base)
  ΩS¹-integers .point   = refl
  ΩS¹-integers .rotate  = rotΩS¹
```

It is easy to see that transporting the basepoint along the family
associated to an automorphism of $X$ commutes with our chosen
automorphism of $\Omega S^1$: modulo a tactic application, it is
`refl`{.Agda}.

```agda
  ΩS¹-integers .map-out        x e l = equiv→action e l x
  ΩS¹-integers .map-out-point  x e   = Regularity.precise! refl
  ΩS¹-integers .map-out-rotate x e l = Regularity.precise! refl
```

The difficult part of the proof is showing that `equiv→action`{.Agda} is
the unique map $\Omega S^1 \to X$ with these properties. We will show
this is the case assuming first that we have an elimination principle
for $\Omega S^1$.

```agda
  ΩS¹-integers .map-out-unique f {p} {r} frefl floop = ΩS¹-elim _
    (Regularity.precise! frefl) $ over-left→over rotΩS¹ λ a →
      (f a ≡ go a)                    ≃⟨ ap-equiv r ⟩
      (r .fst (f a) ≡ r .fst (go a))  ≃⟨ ∙-pre-equiv (floop a) ⟩
      (f (a ∙ loop) ≡ r .fst (go a))  ≃⟨ ∙-post-equiv (Regularity.precise! refl) ⟩
      (f (a ∙ loop) ≡ go (a ∙ loop))  ≃∎
    where
      go : _ → _
      go l = equiv→action r l p
```

### Induction for loops

We must now show the elimination principle for $\Omega S^1$ that was
promised above. Note that, while this is a path type, both of the
endpoints are fixed (here, to be constructors), so we can not directly
use path induction. Instead, we will mimic the construction of
[[induction from initiality]], turning our induction methods into a
*total algebra* and then fixing up its type to get what we want.
However, since we do not have initiality, we'll have to replace the
coherence with something handcrafted.

We note that the induction methods for `ΩS¹-elim`{.Agda} fit together
into a basepoint and auto-equivalence of the type $\sum_{l : \Omega S^1}
P(l)$. The family associated to this action will be called
`totl`{.Agda}, and we will also need a name for the family associated to
`rotΩS¹`{.Agda}.

```agda
  ΩS¹-elim P pr pl l = subst P (pathβ base l) attempt where
    base≡ totl : S¹ → Type _
    base≡ = equiv→family rotΩS¹
    totl  = equiv→family (over→total rotΩS¹ pl)
```

By rotating the basepoint (given by the method $pr : P\ \rm{base}$), we
get a value in $P$, but its type appears to be way off. Essentially, to
show that our `attempt`{.Agda} landed in the right fibre, we would like
to reduce to the case where $l = \refl$, since there the index is
essentially trivially correct.

However, our statement depends critically on $l$ being a loop,
preventing us from using path induction. Instead, we will take a detour
and construct two different fibrewise transformations into
`base≡`{.Agda} at an arbitrary $y : S^1$; at the basepoint, we will
arrange for one of these transformations to be definitionally the
identity, and for the other to be the first projection from the total
space of $P$. We can then apply path induction to show that, if these
agree at $\refl$, they agree at any $p : \rm{base} \is y$, and then we
may specialise with $p = l$.

```agda
    attempt : P (subst totl l (refl , pr) .fst)
    attempt = subst totl l (refl , pr) .snd
```

First, we extend the identity function. This incurs a minor proof
obligation, namely that if we have $x_0, x_1 : \Omega S^1$ which are
identical as elements of $y \mapsto \rm{base} \is y$ *over* the
`loop`{.Agda}, i.e. that $x_1 = x_0 \cdot \rm{loop}$, then these are
also identified in `base≡`{.Agda} over the `loop`{.Agda}, which by
definition is the same thing.

```agda
    to-base≡ : ∀ y → base ≡ y → base≡ y
    to-base≡ = S¹-elim (λ x → x) $ funext-dep λ {x₀} {x₁} α →
      let
        have : x₁ ≡ x₀ ∙ loop
        have = sym (from-pathp α) ∙ subst-path-right _ _

        want : PathP (λ i → ua (∙-post-equiv loop) i) x₀ x₁
        want = path→ua-pathp (∙-post-equiv loop) (sym have)
      in want
```

Next, we extend the first projection from the total algebra $\sum_{x :
\Omega S^1} P(x)$ to a map between arbitrary fibres of `totl`{.Agda} and
`base≡`{.Agda}. Here the coherence is even easier: we have an
identification in some total space and we want an identification in its
base; modulo the use of some `ua`{.Agda}-related helpers, this turns out
to be `refl`{.Agda}.

```agda
    path : ∀ y → totl y → base≡ y
    path = S¹-elim fst $ ua→ λ _ → path→ua-pathp _ refl
```

Finally, we can use path induction to show that the two ways of mapping
a loop into `base≡`{.Agda} agree, where one is the identity and the
other is the first projection from rotating our basepoint. This
completes the proof of the elimination principle, and indeed of the
universal property.

```agda
    pathβ : ∀ y l → path y (subst totl l (refl , pr)) ≡ to-base≡ y l
    pathβ y = J (λ y l → path y (subst totl l (refl , pr)) ≡ to-base≡ y l)
      (transport-refl refl)
  ```

```agda
ΩS¹≃Int : (base ≡ base) ≃ Int
ΩS¹≃Int = Integers-unique ΩS¹-integers Int-integers

open Equiv ΩS¹≃Int renaming (from to loopⁿ) using ()
```

It immediately follows from this that the circle is a [[groupoid]],
since it is connected and its loop space is a set.

```agda
opaque
  S¹-is-groupoid : is-groupoid S¹
  S¹-is-groupoid = S¹-elim (S¹-elim
    (Equiv→is-hlevel 2 ΩS¹≃Int (hlevel 2)) prop!) prop!
```

<!--
```agda
instance
  H-Level-S¹ : ∀ {k} → H-Level S¹ (3 + k)
  H-Level-S¹ = basic-instance 3 S¹-is-groupoid

opaque
  loopⁿ⁺¹ : (n : Int) → loopⁿ (sucℤ n) ≡ loopⁿ n ∙ loop
  loopⁿ⁺¹ n = Int-integers .map-out-rotate refl rotΩS¹ n
```
-->

By induction, we can show that this equivalence respects group composition
(that is, $\rm{loop}^{a + b} \equiv \rm{loop}^a \bullet \rm{loop}^b$), so that we have a
proper isomorphism of groups.

```agda
loopⁿ-+ : (a b : Int) → loopⁿ (a +ℤ b) ≡ loopⁿ a ∙ loopⁿ b
loopⁿ-+ a = Integers.induction Int-integers
  (ap loopⁿ (+ℤ-zeror a) ∙ sym (∙-idr _))
  λ b →
    loopⁿ (a +ℤ b) ≡ loopⁿ a ∙ loopⁿ b                 ≃⟨ ap (_∙ loop) , equiv→cancellable (∙-post-equiv loop .snd) ⟩
    loopⁿ (a +ℤ b) ∙ loop ≡ (loopⁿ a ∙ loopⁿ b) ∙ loop ≃⟨ ∙-post-equiv (sym (∙-assoc _ _ _)) ⟩
    loopⁿ (a +ℤ b) ∙ loop ≡ loopⁿ a ∙ loopⁿ b ∙ loop   ≃⟨ ∙-post-equiv (ap (loopⁿ a ∙_) (sym (loopⁿ⁺¹ b))) ⟩
    loopⁿ (a +ℤ b) ∙ loop ≡ loopⁿ a ∙ loopⁿ (sucℤ b)   ≃⟨ ∙-pre-equiv (loopⁿ⁺¹ (a +ℤ b)) ⟩
    loopⁿ (sucℤ (a +ℤ b)) ≡ loopⁿ a ∙ loopⁿ (sucℤ b)   ≃⟨ ∙-pre-equiv (ap loopⁿ (+ℤ-sucr a b)) ⟩
    loopⁿ (a +ℤ sucℤ b) ≡ loopⁿ a ∙ loopⁿ (sucℤ b)     ≃∎

π₁S¹≡ℤ : π₁Groupoid.π₁ S¹∙ S¹-is-groupoid ≡ ℤ
π₁S¹≡ℤ = sym $ ∫-Path
  (∫hom (Equiv.from ΩS¹≃Int)
    (record { pres-⋆ = loopⁿ-+ }))
  ((ΩS¹≃Int e⁻¹) .snd)
```

Furthermore, since the loop space of the circle is a set, we automatically
get that all of its higher homotopy groups are trivial.

```agda
Ωⁿ⁺²S¹-is-contr : ∀ n → is-contr ⌞ Ωⁿ (2 + n) S¹∙ ⌟
Ωⁿ⁺²S¹-is-contr zero = is-prop∙→is-contr (hlevel 1) refl
Ωⁿ⁺²S¹-is-contr (suc n) = Path-is-hlevel 0 (Ωⁿ⁺²S¹-is-contr n)

πₙ₊₂S¹≡0 : ∀ n → πₙ₊₁ (suc n) S¹∙ ≡ Zero-group {lzero}
πₙ₊₂S¹≡0 n = ∫-Path
  (Zero-group-is-terminal _ .centre)
  (is-contr→≃ (is-contr→∥-∥₀-is-contr (Ωⁿ⁺²S¹-is-contr n)) (hlevel 0) .snd)
```
