<!--
```agda
open import Algebra.Ring.Module.Action
open import Algebra.Group.Subgroup
open import Algebra.Ring.Module
open import Algebra.Group.Ab
open import Algebra.Prelude
open import Algebra.Group
open import Algebra.Ring

open import Data.Power
```
-->

```agda
module Algebra.Ring.Ideal where
```

# Ideals in rings

An **ideal** in a ring $R$ is the [$\Ab$-enriched] analogue of a
[sieve], when $R$ is considered as an $\Ab$-category with a single
object, in that it picks out a sub-[$R$-module] of $R$, considered as a
[representable module], in exactly the same way that a sieve on an
object $x : \cC$ picks out a subfunctor of $\yo(x)$. Since we know that
$\baut R$'s composition is given by $R$'s multiplication, and sieves are
subsets closed under precomposition, we instantly deduce that ideals are
closed under multiplication.

[$\Ab$-enriched]: Cat.Abelian.Base.html#ab-enriched-categories
[sieve]: Cat.Diagram.Sieve.html
[$R$-module]: Algebra.Ring.Module.html#modules
[representable module]: Algebra.Ring.Module.html#representable-modules

In the $\Ab$-enriched setting, however, there are some more operations
that leaves us in the same $\hom$-group: addition! More generally, the
[[abelian group]] operations, i.e. addition, inverse, and the zero
morphism.  Putting these together we conclude that an ideal in $R$ is a
subset of $R$ containing the identity, which is closed under
multiplication and addition.


```agda
module _ {â„“} (R : Ring â„“) where
  private module R = Ring-on (R .snd)

  record is-ideal (ğ” : â„™ âŒ R âŒŸ) : Type (lsuc â„“) where
    no-eta-equality
    field
      has-rep-subgroup : represents-subgroup R.additive-group ğ”

      -- Note: these are named after the side the scalar acts on.
      has-*â‚— : âˆ€ x {y} â†’ y âˆˆ ğ” â†’ (x R.* y) âˆˆ ğ”
      has-*áµ£ : âˆ€ x {y} â†’ y âˆˆ ğ” â†’ (y R.* x) âˆˆ ğ”
```

:::{.note}
Since most of the rings over which we want to consider ideals
are _commutative_ rings, we will limit ourselves to the definition of
_two-sided_ ideals: Those for which we have, for $y \in \mathfrak{a}$
and any element $x : R$, $xy \in \mathfrak{a}$ and $yx \in
\mathfrak{a}$.
:::

<!--
```agda
    open represents-subgroup has-rep-subgroup
      renaming ( has-unit to has-0 ; has-â‹† to has-+ ; has-inv to has-neg )
      public

    idealâ†’normal : normal-subgroup R.additive-group ğ”
    idealâ†’normal .normal-subgroup.has-rep = has-rep-subgroup
    idealâ†’normal .normal-subgroup.has-conjugate {y = y} xâˆˆğ” =
      subst (_âˆˆ ğ”) (sym (ap (y R.+_) R.+-commutes âˆ™ R.cancell R.+-invr)) xâˆˆğ”

    open normal-subgroup idealâ†’normal hiding (has-rep) public
```
-->

Since an ideal is a [subgroup] of $R$'s additive group, its total space
inherits a group structure, and since multiplication in $R$ distributes
over addition in $R$, the group structure induced on $\mathfrak{a}$
carries a canonical $R$-module structure.

[subgroup]: Algebra.Group.Subgroup.html

```agda
  idealâ†’module : (ğ” : â„™ âŒ R âŒŸ) â†’ is-ideal ğ” â†’ Module R â„“
  idealâ†’module ğ” x = g .fst , mod where
    open Ring-action
    open is-ideal x
    gr : Group-on _
    gr = rep-subgroupâ†’group-on ğ” has-rep-subgroup

    g = from-commutative-group (el! _ , gr) Î» x y â†’ Î£-prop-path! R.+-commutes

    mod : Module-on R âŒ g âŒŸ
    mod = Actionâ†’Module-on R {G = g .snd} Î» where
      ._â‹†_ r (a , b) â†’ _ , has-*â‚— r b
      .â‹†-distribl r x y â†’ Î£-prop-path! R.*-distribl
      .â‹†-distribr r s x â†’ Î£-prop-path! R.*-distribr
      .â‹†-assoc r s x    â†’ Î£-prop-path! R.*-associative
      .â‹†-id x           â†’ Î£-prop-path! R.*-idl
```

Since a map between modules is a [[monomorphism]] when its underlying
function is injective, and the first projection from a subset is always
injective, we can quickly conclude that the module structure on
$\mathfrak{a}$ is a sub-$R$-module of $R$:

```agda
  idealâ†’submodule
    : {ğ” : â„™ âŒ R âŒŸ} (idl : is-ideal ğ”)
    â†’ idealâ†’module ğ” idl R-Mod.â†ª representable-module R
  idealâ†’submodule {ğ” = ğ”} idl = record
    { mor   = total-hom fst (record { linear = Î» _ _ _ â†’ refl })
    ; monic = Î» {c = c} g h x â†’ Structured-hom-path (R-Mod-structure R) $
      embeddingâ†’monic (Subset-proj-embedding Î» _ â†’ ğ” _ .is-tr) (g .hom) (h .hom) (ap hom x)
    }
```

## Principal ideals

Every element $a : R$ generates an ideal: that of its multiples, which
we denote $(a)$. You'll note that we have to use the $\exists$
quantifier (rather than the $\sigma$ quantifier) to define $(a)$, since
in an arbitrary ring, multiplication by $a$ may fail to be injective,
so, given $a, b : R$ $b = ca = c'a$, we can't in general conclude that
$c = c'$.  Of course, in _any_ ring, multiplication _by zero_ is never
injective.

Note that, since our ideals are all two-sided (for simplicity) but our
rings may not be commutative (for expressiveness), if we want the ideal
generated by an element to be two-sided, then our ring must be
commutative.

```agda
  principal-ideal
    : (âˆ€ x y â†’ x R.* y â‰¡ y R.* x)
    â†’ (a : âŒ R âŒŸ)
    â†’ is-ideal Î» b â†’ elÎ© (Î£ _ Î» c â†’ b â‰¡ c R.* a)
  principal-ideal comm a = record
    { has-rep-subgroup = record
      { has-unit = pure (_ , sym R.*-zerol)
      ; has-â‹†    = Î» x y â†’ do
          (xi , p) â† x
          (yi , q) â† y
          pure (xi R.+ yi , apâ‚‚ R._+_ p q âˆ™ sym R.*-distribr)
      ; has-inv  = Î» x â†’ do
          (xi , p) â† x
          pure (R.- xi , ap R.-_ p âˆ™ R.neg-*-l)
      }
    ; has-*â‚— = Î» x y â†’ do
        (yi , q) â† y
        pure (x R.* yi , ap (x R.*_) q âˆ™ R.*-associative)
    ; has-*áµ£ = Î» x y â†’ do
        (yi , q) â† y
        pure ( yi R.* x
             , ap (R._* x) q Â·Â· sym R.*-associative Â·Â· ap (yi R.*_) (comm a x)
             âˆ™ R.*-associative)
    }
```
