```agda
open import Data.Int.Inductive
open import 1Lab.Path.Groupoid
open import 1Lab.Univalence
open import Data.Bool
open import 1Lab.Type.Dec
open import 1Lab.Equiv
open import 1Lab.Path
open import 1Lab.Type

open import Data.Bool

module 1Lab.HIT.S1 where
```

# The Circle

Since the “intended interpretation” of HoTT is in a
$(\infty,1)$-category of “good spaces”, it makes sense that HoTT has
facilities for describing spaces. These are the _higher inductive
types_, one of which is the **circle**:

```agda
data S¹ : Type where
  base : S¹
  loop : base ≡ base
```

Diagramatically, we can picture the circle as being the
$\infty$-groupoid generated by the following diagram:

~~~{.quiver}
\begin{tikzpicture}
\node[draw,circle,label=below:{$\mathrm{base}$},fill,outer sep=0.1cm, inner sep=0pt, minimum size=0.1cm] (a0) at (0, -1) {};
\draw[->] (0, 0) circle (1cm);
\node[] (loop) at (0, 0) {$\mathrm{loop}\ i$};
\end{tikzpicture}
~~~

In type theory with K, the circle is exactly the same type as
`⊤`{.Agda}. However, with `univalence`{.Agda ident=ua}, it can be shown
that the circle has two different paths:

<!--
```
_ = ⊤
```
-->

```agda
möbius : S¹ → Type
möbius base = Bool
möbius (loop i) = ua (not , isEquiv-not) i
```

When pattern matching on the crcle, we are asked to provide a basepoint
`b` and a path `l : b ≡ b`, as can be seen in the definition above. To
make it clearer, we can also define a recursion principle: 

```agda
S¹-rec : ∀ {ℓ} {A : Type ℓ} (b : A) (l : b ≡ b) → S¹ → A
S¹-rec b l base = b
S¹-rec b l (loop i) = l i
```

Using `möbius`{.Agda}, it can be shown that the `loop`{.Agda} is not
`refl`{.Agda}:

```agda
parity : base ≡ base → Bool
parity l = subst möbius l true

_ : parity refl ≡ true
_ = refl

_ : parity loop ≡ false
_ = refl

refl≠loop : refl ≡ loop → ⊥
refl≠loop path = true≠false (ap parity path)
```

The circle is also useful as a source of counterexamples. By
`S¹-elim'`{.Agda}, we can prove that there is an inhabitant of `(x : S¹)
→ x ≡ x` which is not constantly `refl`{.Agda}

```agda
S¹-elim : ∀ {ℓ} {P : S¹ → Type ℓ}
        → (pb : P base)
        → PathP (λ i → P (loop i)) pb pb
        → (x : S¹) → P x
S¹-elim pb pl base = pb
S¹-elim pb pl (loop i) = pl i

S¹-elim' : ∀ {ℓ} {P : S¹ → Type ℓ} (pb : P base)
         → subst P loop pb ≡ pb
         → (x : S¹) → P x
S¹-elim' {P = P} pb pl =
  S¹-elim pb (transport (λ i → PathP≡Path (λ i → P (loop i)) pb pb (~ i)) pl)

always-loop : (x : S¹) → x ≡ x
always-loop = S¹-elim' loop (subst-path-both _ _ ∙ lemma) where
  lemma = sym loop ∙ loop ∙ loop   ≡⟨ ∙-cancel-l loop loop ⟩
          loop                    ∎ 
```

## Path Space

A classical result of algebraic topology is that the fundamental group
of the circle is isomorphic to the group of integers. In Homotopy Type
Theory, we can repeat this proof: The type of integers _codes for_
equalities in the circle.

```agda
module S¹Path where
  Cover : S¹ → Type
  Cover base = Int
  Cover (loop i) = ua sucEquiv i
```

We define a map `encode`{.Agda} which converts a path in the circle to
an element of the `Cover`{.Agda}. By lifting p to the `Cover`{.Agda}, we
determine a path `Int ≡ Int`, which we apply to zero:

```agda
  encode : (x : S¹) → base ≡ x → Cover x
  encode x p = subst Cover p (pos zero)
```

This map counts the _winding number_ of a path:

```agda
  _ : encode base refl ≡ pos zero
  _ = refl

  _ : encode base loop ≡ pos (suc zero)
  _ = refl
```

In the other direction, we define a map `decode`{.Agda} which converts
an integer to a path `base ≡ base`{.Agda}:

```agda
  loop^ : Int → base ≡ base
  loop^ (pos zero) = refl
  loop^ (pos (suc x)) = loop^ (pos x) ∙ loop
  loop^ (negsuc zero) = sym loop
  loop^ (negsuc (suc x)) = loop^ (negsuc x) ∙ sym loop
```

What we want to show is that `encode base` and `loop^` are mutual
inverses. For this, we must show that `encode base (loop^ n) ≡ n` and
`loop^ (encode base p) ≡ p`. The former direction is simpler, because we
can show it directly by recursion on `Int`{.Agda}:

```agda
  encode-loop^ : (n : Int) → encode base (loop^ n) ≡ n
  encode-loop^ (pos zero) = refl
  encode-loop^ (pos (suc x)) = ap sucInt (encode-loop^ (pos x))
  encode-loop^ (negsuc zero) = refl
  encode-loop^ (negsuc (suc x)) = ap predInt (encode-loop^ (negsuc x))
```

For the other direction, we would like to apply _path induction_ to
reduce the problem to showing `loop^ (encode base refl) ≡ refl`.
However, path induction does not apply to paths `base ≡ base`, only to
paths `base ≡ x` for `x` a variable. So, we have to generalise the
function `loop^` to the function `decode`{.Agda}:

```agda
  decode : (x : S¹) → Cover x → base ≡ x
  decode base = loop^
  decode (loop i) n j = square where
```

For the `decode`{.Agda} case, we are asked to provide a square with the
boundary below:

~~~{.quiver}
\[\begin{tikzcd}
  {\mathrm{base}} && {\mathrm{base}} \\
  \\
  {\mathrm{base}} && {\mathrm{base}}
  \arrow["{\mathrm{loop}^n}", from=1-3, to=3-3]
  \arrow["{\mathrm{loop}}"', from=3-1, to=3-3]
  \arrow["{\mathrm{refl}}", from=1-1, to=1-3]
  \arrow["{\mathrm{loop}^n}"', from=1-1, to=3-1]
\end{tikzcd}\]
~~~

We do this in parts. First, we'll construct a square
`loop^-square`{.Agda} with the boundary below, for any $n$, by
recursion; We'll then modify this square so it becomes the one above.

~~~{.quiver}
\[\begin{tikzcd}
  {\mathrm{base}} && {\mathrm{base}} \\
  \\
  {\mathrm{base}} && {\mathrm{base}}
  \arrow["{\mathrm{loop}^n}", from=1-3, to=3-3]
  \arrow["{\mathrm{loop}}"', from=3-1, to=3-3]
  \arrow["{\mathrm{refl}}", from=1-1, to=1-3]
  \arrow["{\mathrm{loop}^{n - 1}}"', from=1-1, to=3-1]
\end{tikzcd}\]
~~~

```agda
    loop^-square : (n : Int) → PathP (λ i → base ≡ loop i)
                                     (loop^ (predInt n))
                                     (loop^ n)
    loop^-square (pos zero) i j = loop (i ∨ ~ j)
```

The case above is for $n = 0$. We can picture it as follows. Note that
this is a square where two faces are the path `loop`{.Agda} and two
faces are degenerate: a [connection].

[connection]: 1Lab.Path.html#raising-dimension

~~~{.quiver}
\[\begin{tikzcd}
  {\mathrm{base}} && {\mathrm{base}} \\
  \\
  {\mathrm{base}} && {\mathrm{base}}
  \arrow["{\mathrm{refl}}", from=1-3, to=3-3]
  \arrow[""{name=0, anchor=center, inner sep=0}, "{\mathrm{loop}}"', from=3-1, to=3-3]
  \arrow[""{name=1, anchor=center, inner sep=0}, "{\mathrm{refl}}", from=1-1, to=1-3]
  \arrow["{\mathrm{sym}\ \mathrm{loop}}"', from=1-1, to=3-1]
  \arrow["{\mathrm{loop}\ (i \lor \neg j)}"{description}, Rightarrow, draw=none, from=1, to=0]
\end{tikzcd}\]
~~~

```agda
    loop^-square (pos (suc x)) i j =
      hfill (λ k → λ { (j = i0) → base
                     ; (j = i1) → loop k })
            (inS (loop^ (pos x) j)) i
```

In the case where $n = +x$, the square we have to fill is the one on the
left below, but note that the composite on the right face is _defined_
to be the dashed path in that square; Thus, the `filler`{.Agda
ident=hfill} of that square suffices. A similar thing happens for the
case where $n = -(x + 1)$, which is the square on the right.

<div class=mathpar>
~~~{.quiver}
\[\begin{tikzcd}
  {\mathrm{base}} && {\mathrm{base}} \\
  \\
  {\mathrm{base}} && {\mathrm{base}}
  \arrow["{\mathrm{loop}^{+x}\bullet \mathrm{loop}}", dashed, from=1-3, to=3-3]
  \arrow[""{name=0, anchor=center, inner sep=0}, "{\mathrm{loop}}"', from=3-1, to=3-3]
  \arrow[""{name=1, anchor=center, inner sep=0}, "{\mathrm{refl}}", from=1-1, to=1-3]
  \arrow["{\mathrm{loop}^{+x}}"', from=1-1, to=3-1]
  \arrow[Rightarrow, draw=none, from=1, to=0]
\end{tikzcd}\]
~~~

~~~{.quiver}
\[\begin{tikzcd}
  {\mathrm{base}} && {\mathrm{base}} \\
  \\
  {\mathrm{base}} && {\mathrm{base}}
  \arrow["{\mathrm{loop}^{-(x+1)}\bullet \mathrm{sym}\ \mathrm{loop}}", dashed, from=1-3, to=3-3]
  \arrow[""{name=0, anchor=center, inner sep=0}, "{\mathrm{sym}\ \mathrm{loop}}"', from=3-1, to=3-3]
  \arrow[""{name=1, anchor=center, inner sep=0}, "{\mathrm{refl}}", from=1-1, to=1-3]
  \arrow["{\mathrm{loop}^{-(x+1)}}"', from=1-1, to=3-1]
  \arrow[Rightarrow, draw=none, from=1, to=0]
\end{tikzcd}\]
~~~
</div>

```agda
    loop^-square (negsuc x) i j =
      hfill (λ k → λ { (j = i0) → base
                     ; (j = i1) → loop (~ k) })
            (inS (loop^ (negsuc x) j)) (~ i)
```

We can then alter the square `loop^-square`{.Agda} to the
`square`{.Agda} we want, by sketching an appropriate cube.

```
    square = hcomp (λ k → λ { (i = i0) → loop^ (predSuc n k) j
                            ; (i = i1) → loop^ n j
                            ; (j = i0) → base
                            ; (j = i1) → loop i })
                   (loop^-square (unglue (i ∨ ~ i) n) i j)
```

With this generalised `decode`{.Agda}, we can prove that `decode x
(encode x p) ≡ p`, by reducing `p` to `refl`{.Agda}, i.e. `path
induction`{.Agda ident=J}. 

```
  decode-encode : {x : S¹} (p : base ≡ x) → decode x (encode x p) ≡ p
  decode-encode = J (λ y p → decode y (encode y p) ≡ p) refl
```

Thus we have that the loop space of the circle is the type of integers:

```
  ΩS¹≃Int : (base ≡ base) ≃ Int
  ΩS¹≃Int = Iso→Equiv (encode base , iso loop^ encode-loop^ decode-encode)
```
