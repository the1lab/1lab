```agda
open import 1Lab.HLevel.Retracts
open import 1Lab.HLevel.Sets
open import 1Lab.Univalence
open import 1Lab.Data.Dec
open import 1Lab.Data.Nat
open import 1Lab.HLevel
open import 1Lab.Equiv
open import 1Lab.Path
open import 1Lab.Type

module 1Lab.Data.Int where
```

# Integers

The **integers** are what you get when you complete the [additive monoid
structure on the naturals] into a [group]. In non-cubical Agda, a
representation of the integers as a coproduct $\mathbb{N} \coprod
\mathbb{N}$ with one of the factors offset (to avoid having two zeroes)
is adopted. In Cubical Agda we can adopt a representation much closer to
a "classical" construction of the integers:

[additive monoid structure on the naturals]: Algebra.Monoid.html#ℕ-+
[group]: Algebra.Group.html

```
data Int : Type where
  diff : (x y : Nat) → Int
  quot : (m n : Nat) → diff m n ≡ diff (suc m) (suc n)
```

This is an alternative representation of the construction of integers as
pairs $(x , y)\colon \mathbb{N}^2$ where $(a,b) = (c, d)$ iff $a + d = b
+ c$: An integer is an equivalence class of pairs of naturals, where
$(a, b)$ is identified with $(1 + a, 1 + b)$, or, more
type-theoretically, the integers are generated by the constructor
`diff`{.Agda} which embeds a pair of naturals, and the path constructor
`quot`{.Agda} which expresses that $(a, b)$ = $(1 + a, 1 + b)$.

As an example of using this generating path, we can prove that any pair
$(a, b)$ has a path to the "canonical zero", $(0, 0)$:

```
zeroes : (n : Nat) → diff 0 0 ≡ diff n n
zeroes zero = refl
zeroes (suc n) = zeroes n ∙ quot _ _
```

Furthermore, offsetting both components by the same natural does nothing:

```
cancel : (a b n : Nat) → diff a b ≡ diff (n + a) (n + b)
cancel a b zero = refl
cancel a b (suc n) = cancel a b n ∙ quot _ _
```

All equivalence classes have a representative of the form $(0,b)$ or
$(b,0)$:

```
offset-negative : (a b : Nat) → diff a (a + b) ≡ diff 0 b
offset-negative zero b = refl
offset-negative (suc a) b =
  diff (suc a) (suc (a + b)) ≡⟨ sym (quot _ _) ⟩
  diff a (a + b)             ≡⟨ offset-negative a b ⟩
  diff 0 b                   ∎

offset-positive : (a b : Nat) → diff (a + b) a ≡ diff b 0
offset-positive zero b = refl
offset-positive (suc a) b =
  diff (suc (a + b)) (suc a) ≡⟨ sym (quot _ _) ⟩
  diff (a + b) a             ≡⟨ offset-positive a b ⟩
  diff b 0                   ∎
```

And finally, we can _prove_ that this definition satisfies the more
common equality used in the construction of integers as a quotient set:
$(a, b) = (c, d)$ if $(a + d) = (b + c)$.

```
same-difference : {a b c d : Nat} → a + d ≡ b + c → diff a b ≡ diff c d
same-difference {zero} {b} {c} {d} path =
  sym ( diff c d       ≡⟨ ap₂ diff refl path ⟩
        diff c (b + c) ≡⟨ ap₂ diff refl (+-commutative b c) ⟩
        diff c (c + b) ≡⟨ offset-negative _ _ ⟩
        diff 0 b       ∎ 
      )
same-difference {suc a} {zero} {c} {d} path =
  sym ( diff c d             ≡⟨ ap₂ diff (sym path) refl ⟩
        diff (suc a + d) d   ≡⟨ ap₂ diff (+-commutative (suc a) d) refl ⟩
        diff (d + suc a) d   ≡⟨ offset-positive _ _ ⟩
        diff (suc a) 0       ∎
      )
same-difference {suc a} {suc b} {c} {d} path =
  diff (suc a) (suc b) ≡⟨ sym (quot _ _) ⟩
  diff a b             ≡⟨ same-difference (suc-inj path) ⟩
  diff c d             ∎
```

Furthermore, using a cubical argument, we can prove that the
`quot`{.Agda} constructor satisfies the following two equalities,
which are necessary when relating `Int`{.Agda} to a more concrete
definition which can be shown to have decidable equality:

```
quot-diamond : (a b : Nat)
             → PathP (λ j → quot a b j ≡ quot (suc a) (suc b) j)
                     (quot a b)
                     (quot (suc a) (suc b))
quot-diamond a b i j =
  hcomp (λ k → λ { (i = i0) → quot a b j
                 ; (i = i1) → quot (suc a) (suc b) (j ∧ k)
                 ; (j = i0) → quot a b i
                 ; (j = i1) → quot (suc a) (suc b) (i ∧ k)
                 })
        (quot a b (i ∨ j))

quot-triangle : (a b : Nat) (i : I) → diff a b ≡ quot a b i
quot-triangle a b i j = hcomp (λ k → λ
  { (i = i0) → diff a b
  ; (j = i0) → diff a b
  ; (j = i1) → quot a b (i ∧ k)
  }) (diff a b)
```

As a finishing touch, we give `Int` instances for `Number`{.Agda} and
`Negative`{.Agda}, meaning that we can use positive and negative
literals with integer type:

```
instance
  Number-Int : Number Int
  Number-Int .Number.Constraint _ = ⊤
  Number-Int .Number.fromNat n = diff n 0

  Negative-Int : Negative Int
  Negative-Int .Negative.Constraint _ = ⊤
  Negative-Int .Negative.fromNeg n = diff 0 n
```

## Discreteness

To prove that `Int`{.Agda} is [discrete] (and thus [a set]), we prove
that it is equivalent to an inductive (rather than higher-inductive)
definition of the integers. Since this definition (which we call
`Int'`{.Agda}) has decidable equality, it is a set.

[discrete]: agda://1Lab.Data.Dec#Discrete
[a set]: agda://1Lab.HLevel#isSet


```
module _ where
  private
    data Int' : Type where
      pos : Nat → Int'
      negsuc : Nat → Int'
```

As the names indicate, these constructors are meant to represent a
`pos`{.Agda}itive integer, and the `negation of a successor`{.Agda
ident=negsuc} of a natural number, i.e. `negsuc`{.Agda} is the map
taking $n$ to $-(n + 1)$.

```
    _ℕ-_ : Nat → Nat → Int'
    x ℕ- zero = pos x
    zero ℕ- suc y = negsuc y
    suc x ℕ- suc y = x ℕ- y
```

There is a canonical map which takes pairs of naturals to their
difference as an `Int'`{.Agda}; It can be shown that this map extends to
a function from `Int`{.Agda}, since it respects the generating equation
`quot`{.Agda} definitionally (that's the third clause):

```
    toInt' : Int → Int'
    toInt' (diff x y) = x ℕ- y
    toInt' (quot m n i) = m ℕ- n

    fromInt' : Int' → Int
    fromInt' (pos x) = diff x 0
    fromInt' (negsuc x) = diff 0 (suc x)
```

Mapping from `Int'`{.Agda} to `Int`{.Agda} sends the positive numbers to
$(x, 0)$ and the negative numbers to $(0, x)$.

```
    toFromInt' : (x : Int) → fromInt' (toInt' x) ≡ x
    toFromInt' (diff x zero)            = refl
    toFromInt' (diff zero (suc y))      = refl
    toFromInt' (diff (suc x) (suc y))   = toFromInt' (diff x y) ∙ quot _ _

    toFromInt' (quot m zero i)          = quot-triangle _ _ i
    toFromInt' (quot zero (suc n) i)    = quot-triangle _ _ i
    toFromInt' (quot (suc m) (suc n) i) =
      toFromInt' (quot _ _ i) ∙ quot-diamond _ _ i

    fromToInt' : (x : Int') → toInt' (fromInt' x) ≡ x
    fromToInt' (pos x) = refl
    fromToInt' (negsuc x) = refl

    Int'≡Int : Int' ≡ Int
    Int'≡Int = Iso→path (fromInt' , iso toInt' toFromInt' fromToInt')
```

We can decide equality of two `Int'`{.Agda}s by `comparing`{.Agda
ident=Discrete-Nat} their underlying naturals when the constructors
match (i.e. `pos`{.Agda}/`pos`{.Agda} or
`negsuc`{.Agda}/`negsuc`{.Agda}):

```
    Discrete-Int' : Discrete Int'
    Discrete-Int' (pos x) (pos y) with Discrete-Nat x y
    ... | yes p = yes (ap pos p)
    ... | no ¬p = no λ path → ¬p (ap (λ { (pos x) → x ; _ → zero }) path)

    Discrete-Int' (negsuc x) (negsuc y) with Discrete-Nat x y
    ... | yes p = yes (ap negsuc p)
    ... | no ¬p = no λ path → ¬p (ap (λ { (negsuc x) → x ; _ → zero }) path)
```

And in case the constructors are mismatched, there can be no path
between them:

```
    Discrete-Int' (pos x) (negsuc y) =
      no λ path → subst (λ { (pos x) → ⊤ ; _ → ⊥ }) path tt
    Discrete-Int' (negsuc x) (pos y) =
      no λ path → subst (λ { (pos x) → ⊥ ; _ → ⊤ }) path tt
```

With a quick appeal to `univalence`{.Agda ident=Iso→path}, we get that
our desired type of integers is a set:

```
  Discrete-Int : Discrete Int
  Discrete-Int = subst Discrete Int'≡Int Discrete-Int'

  isSet-Int : isSet Int
  isSet-Int = Discrete→isSet Discrete-Int
```

# Recursion

If we want to define a map $f : \mathbb{Z} \to X$, it suffices to give a
function $f : \mathbb{N}^2 \to X$ which respects the quotient, in the
following sense:

```
Int-rec : {ℓ : _} {X : Type ℓ}
        → (f : Nat → Nat → X)
        → (q : (a b : _) → f a b ≡ f (suc a) (suc b))
        → Int → X
Int-rec f q (diff x y) = f x y
Int-rec f q (quot m n i) = q m n i
```

However, since $X$ can be a more general space and not just a set,
defining a _binary_ operation $f' : \mathbb{Z}^2 \to X$ can be quite
involved! It doesn't suffice to exhibit a function from $\mathbb{N}^4$
which respects the quotient separately in each argument:

```
Int-rec₂ : {ℓ : _} {B : Type ℓ}
         → (f : Nat × Nat → Nat × Nat → B)
         → (pl     : (a b x y : _) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
         → (pr     : (a b x y : _) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y))
```

In addition, we must have that these two _paths_ `pl` and `pr` are
_coherent_. There are two ways of obtaining an equality $f(a, b, x, y) =
f(\mathrm{S}a,\mathrm{S}b,\mathrm{S}x,\mathrm{S}y)$ (`pl` after `pr` and
`pr` after `pl`, respectively) and these _must_ be homotopic:

```
         → (square : (a b x y : _) →
              PathP (λ i → pl a b x y i ≡ pl a b (suc x) (suc y) i)
                    (pr a b x y)
                    (pr (suc a) (suc b) x y))
         → Int → Int → B
```

The type of `square` says that we need the following square of paths to
commute, which says exactly that `pl ∙ pr` and `pr ∙ pl` are homotopic
and imposes no further structure on $X$[^1]:

[^1]: In the diagram, we write $\mathrm{S}x$ for `suc x`.

~~~{.quiver .tall-1}
\[\begin{tikzcd}
  {f(a,b,x,y)} && {f(a,b,\mathrm{S}x,\mathrm{S}y)} \\
  \\
  {f(\mathrm{S}a,\mathrm{S}b, x, y)} && {f(\mathrm{S}a,\mathrm{S}b,\mathrm{S}x,\mathrm{S}y)}
  \arrow["{pl(a,b,x,y)}", from=1-1, to=3-1]
  \arrow["{pr(a,b,x,y)}", from=1-1, to=1-3]
  \arrow["{pl(a,b,\mathrm{S}x,\mathrm{S}y)}"', from=1-3, to=3-3]
  \arrow["{pr(\mathrm{S}a,\mathrm{S}b,x,y)}"', from=3-1, to=3-3]
\end{tikzcd}\]
~~~

```
Int-rec₂ f p-l p-r sq (diff a b) (diff x y)     = f (a , b) (x , y)
Int-rec₂ f p-l p-r sq (diff a b) (quot x y i)   = p-r a b x y i
Int-rec₂ f p-l p-r sq (quot a b i) (diff x y)   = p-l a b x y i
Int-rec₂ f p-l p-r sq (quot a b i) (quot x y j) = sq a b x y i j
```

However, when the type $X$ we are mapping into `is a set`{.Agda
ident=isSet}, as is the case for the integers themselves, the square is
automatically satisfied, so we can give a simplified recursion
principle:

```
Int-rec₂-set :
    {ℓ : _} {B : Type ℓ}
  → isSet B
  → (f : Nat × Nat → Nat × Nat → B)
  → (pl     : (a b x y : _) → f (a , b) (x , y) ≡ f (suc a , suc b) (x , y))
  → (pr     : (a b x y : _) → f (a , b) (x , y) ≡ f (a , b) (suc x , suc y))
  → Int → Int → B
Int-rec₂-set iss-b f pl pr = Int-rec₂ f pl pr square where
  square : (a b x y : _) → _
  square a b x y =
    transport (λ i → PathP≡Path (λ i → pl a b x y i ≡ pl a b (suc x) (suc y) i)
                                (pr a b x y) (pr (suc a) (suc b) x y)
                                (~ i))
              (iss-b _ _ _ _)
```

Furthermore, when proving _`propositions`{.Agda ident=isProp}_ of the
integers, the quotient is automatically respected, so it suffices to
give the case for `diff`{.Agda}:

```
Int-elim-prop : {ℓ : _} {P : Int → Type ℓ}
              → ((x : Int) → isProp (P x))
              → (f : (a b : Nat) → P (diff a b))
              → (x : Int) → P x
Int-elim-prop pprop f (diff a b) = f a b
Int-elim-prop pprop f (quot m n i) =
  isProp→PathP (λ i → pprop (quot m n i)) (f m n) (f (suc m) (suc n)) i
```

<details>
<summary>There are also variants for binary and ternary predicates.</summary>
```
Int-elim₂-prop : {ℓ : _} {P : Int → Int → Type ℓ}
               → ((x y : Int) → isProp (P x y))
               → (f : (a b x y : Nat) → P (diff a b) (diff x y))
               → (x : Int) (y : Int) → P x y
Int-elim₂-prop pprop f =
  Int-elim-prop (λ x → isHLevelΠ 1 (pprop x))
    λ a b int → Int-elim-prop (λ x → pprop (diff a b) x) (f a b) int

Int-elim₃-prop : {ℓ : _} {P : Int → Int → Int → Type ℓ}
               → ((x y z : Int) → isProp (P x y z))
               → (f : (a b c d e f : Nat) → P (diff a b) (diff c d) (diff e f))
               → (x : Int) (y : Int) (z : Int) → P x y z
Int-elim₃-prop pprop f =
  Int-elim₂-prop (λ x y → isHLevelΠ 1 (pprop x y))
    λ a b c d int → Int-elim-prop (λ x → pprop (diff a b) (diff c d) x)
                                  (f a b c d)
                                  int
```
</details>

# Algebra

With these recursion and elimination helpers, it becomes routine to lift
the algebraic operations from naturals to integers:

## Successors

The simplest "algebraic operation" on an integer is taking its
successor. In fact, the integers are characterised by being the free
type with an equivalence - that equivalence being "successor".

```
sucℤ : Int → Int
sucℤ (diff x y) = diff (suc x) y
sucℤ (quot m n i) = quot (suc m) n i

predℤ : Int → Int
predℤ (diff x y) = diff x (suc y)
predℤ (quot m n i) = quot m (suc n) i
```

The successor of $(a, b)$ is $(1 + a, b)$. Similarly, the predecessor of
$(a, b)$ is $(a, 1 + b)$. By the generating equality `quot`{.Agda}, we
have that predecessor and successor are inverses, since applying both
(in either order) takes $(a, b)$ to $(1 + a, 1 + b)$.

```
predSucℤ : (x : Int) → predℤ (sucℤ x) ≡ x
predSucℤ (diff x y) = sym (quot x y)
predSucℤ (quot m n i) j = quot-diamond m n i (~ j)

sucPredℤ : (x : Int) → sucℤ (predℤ x) ≡ x
sucPredℤ (diff x y) = sym (quot x y)
sucPredℤ (quot m n i) j = quot-diamond m n i (~ j)

isEquiv-sucℤ : isEquiv sucℤ
isEquiv-sucℤ = isIso→isEquiv (iso predℤ sucPredℤ predSucℤ)

isEquiv-predℤ : isEquiv predℤ
isEquiv-predℤ = isIso→isEquiv (iso sucℤ predSucℤ sucPredℤ)
```

## Addition

```
_+ℤ_ : Int → Int → Int
_+ℤ_ =
  Int-rec₂-set
    isSet-Int
    (λ { (a , b) (c , d) → diff (a + c) (b + d)})
    (λ a b x y → quot _ _)
    (λ a b x y → quot _ _ ∙ ap₂ diff (sym (+-sucʳ _ _)) (sym (+-sucʳ _ _)))
```

Since addition of integers is (essentially!) addition of pairs of
naturals, the algebraic properties of `+`{.Agda} on the natural numbers
automatically lift to properties about `_+ℤ_`{.Agda}, using the
recursion helpers for props (`Int-elim-prop`{.Agda}) and the fact that
`equality of integers is a proposition`{.Agda ident=isSet-Int}.

```
+ℤ-associative : (x y z : Int) → (x +ℤ y) +ℤ z ≡ x +ℤ (y +ℤ z)
+ℤ-associative =
  Int-elim₃-prop
    (λ x y z → isSet-Int _ _)
    (λ a b c d e f → ap₂ diff (+-associative a c e) (+-associative b d f))

+ℤ-zeroˡ : (x : Int) → 0 +ℤ x ≡ x
+ℤ-zeroˡ = Int-elim-prop (λ x → isSet-Int _ _) (λ a b → refl)

+ℤ-zeroʳ : (x : Int) → x +ℤ 0 ≡ x
+ℤ-zeroʳ =
  Int-elim-prop (λ x → isSet-Int _ _) (λ a b → ap₂ diff (+-zeroʳ a) (+-zeroʳ b))

+ℤ-commutative : (x y : Int) → x +ℤ y ≡ y +ℤ x
+ℤ-commutative =
  Int-elim₂-prop (λ x y → isSet-Int _ _)
    (λ a b c d → ap₂ diff (+-commutative a c) (+-commutative b d))
```

## Inverses

Every integer $x$ has an additive inverse, denoted $-x$, which is
obtained by swapping the components of the pair. Since the definition of
`negate`{.Agda} is very simple, it can be written conveniently without
using `Int-rec`{.Agda}:

```
negate : Int → Int
negate (diff x y) = diff y x
negate (quot m n i) = quot n m i
```

The proof that $-x$ is an additive inverse to $x$ follows, essentially,
from commutativity of addition on natural numbers, and the fact that
`all zeroes are identified`{.Agda ident=zeroes}.

```
+ℤ-inverseʳ : (x : Int) → x +ℤ negate x ≡ 0
+ℤ-inverseʳ =
  Int-elim-prop (λ _ → isSet-Int _ _) λ where
    a b → diff (a + b) (b + a) ≡⟨ ap₂ diff refl (+-commutative b a) ⟩
          diff (a + b) (a + b) ≡⟨ sym (zeroes (a + b)) ⟩
          diff 0 0             ∎
          
+ℤ-inverseˡ : (x : Int) → negate x +ℤ x ≡ 0
+ℤ-inverseˡ =
  Int-elim-prop (λ _ → isSet-Int _ _) λ where
    a b → diff (b + a) (a + b) ≡⟨ ap₂ diff (+-commutative b a) refl ⟩
          diff (a + b) (a + b) ≡⟨ sym (zeroes (a + b)) ⟩
          diff 0 0             ∎
```

Since `negate`{.Agda} is precisely what's missing for `Nat`{.Agda} to be
a group, we _can_ turn [the integers] into a group. Subtraction is
defined as addition with the inverse, rather than directly on `diff`{.Agda}:

[the integers]: 1Lab.Algebra.Group.html#the-integers

```
_-ℤ_ : Int → Int → Int
x -ℤ y = x +ℤ negate y
```
