```agda
open import 1Lab.Data.Relation.Order
open import 1Lab.HLevel.Sets
open import 1Lab.Data.Dec
open import 1Lab.HLevel
open import 1Lab.Path
open import 1Lab.Type

module 1Lab.Data.Nat where
```

# Natural Numbers

The natural numbers are the inductive type generated by `zero`{.Agda}
and closed under taking `suc`{.Agda}cessors. Thus, they satisfy the
following induction principle, which is familiar:

```agda
Nat-elim : ∀ {ℓ} (P : Nat → Type ℓ)
         → P 0
         → ({n : Nat} → P n → P (suc n))
         → (n : Nat) → P n
Nat-elim P pz ps zero    = pz
Nat-elim P pz ps (suc n) = Nat-elim (λ z → P (suc z)) (ps pz) ps n
```

## Algebraic properties

Agda already provides definitions of `+`{.Agda} and `*`{.Agda}, but
not any properties of them. The proofs in this section should be
self-explanatory:

```agda
+-associative : (x y z : Nat) → (x + y) + z ≡ x + (y + z)
+-associative zero y z = refl
+-associative (suc x) y z =
  suc ((x + y) + z) ≡⟨ ap suc (+-associative x y z) ⟩
  suc (x + (y + z)) ∎

+-zeroʳ : (x : Nat) → x + 0 ≡ x
+-zeroʳ zero = refl
+-zeroʳ (suc x) =
  suc (x + 0) ≡⟨ ap suc (+-zeroʳ x) ⟩
  suc x       ∎

+-sucʳ : (x y : Nat) → x + suc y ≡ suc (x + y)
+-sucʳ zero y = refl
+-sucʳ (suc x) y = ap suc (+-sucʳ x y)

+-commutative : (x y : Nat) → x + y ≡ y + x
+-commutative zero y = sym (+-zeroʳ y)
+-commutative (suc x) y =
  suc (x + y) ≡⟨ ap suc (+-commutative x y) ⟩
  suc (y + x) ≡⟨ sym (+-sucʳ y x) ⟩
  y + suc x   ∎

*-distrib-+ʳ : (x y z : Nat) → (x + y) * z ≡ x * z + y * z
*-distrib-+ʳ zero y z = refl
*-distrib-+ʳ (suc x) y z =
  z + (x + y) * z     ≡⟨ ap₂ _+_ refl (*-distrib-+ʳ x y z) ⟩
  z + (x * z + y * z) ≡⟨ sym (+-associative z (x * z) (y * z)) ⟩
  z + x * z + y * z   ∎

*-sucʳ : (m n : Nat) → m * suc n ≡ m + m * n
*-sucʳ zero    n = refl
*-sucʳ (suc m) n =
  suc m * suc n         ≡⟨⟩
  suc n + m * suc n     ≡⟨ ap₂ _+_ refl (*-sucʳ m n) ⟩
  suc n + (m + m * n)   ≡⟨⟩
  suc (n + (m + m * n)) ≡⟨ ap suc (sym (+-associative n m (m * n))) ⟩
  suc (n + m + m * n)   ≡⟨ ap (λ x → suc (x + m * n)) (+-commutative n m) ⟩
  suc (m + n + m * n)   ≡⟨ ap suc (+-associative m n (m * n)) ⟩
  suc (m + (n + m * n)) ≡⟨⟩
  suc m + suc m * n     ∎

*-oneʳ : (x : Nat) → x * 1 ≡ x
*-oneʳ zero = refl
*-oneʳ (suc x) =
  suc (x * 1) ≡⟨ ap suc (*-oneʳ x) ⟩
  suc x       ∎

*-zeroʳ : (x : Nat) → x * 0 ≡ 0
*-zeroʳ zero = refl
*-zeroʳ (suc x) = *-zeroʳ x

*-commutative : (x y : Nat) → x * y ≡ y * x
*-commutative zero y    = sym (*-zeroʳ y)
*-commutative (suc x) y =
  y + x * y ≡⟨ ap₂ _+_ refl (*-commutative x y) ⟩
  y + y * x ≡⟨ sym (*-sucʳ y x) ⟩
  y * suc x ∎

*-distrib-+ˡ : (x y z : Nat) → z * (x + y) ≡ z * x + z * y
*-distrib-+ˡ x y z =
  z * (x + y)   ≡⟨ *-commutative z (x + y) ⟩
  (x + y) * z   ≡⟨ *-distrib-+ʳ x y z ⟩
  x * z + y * z ≡⟨ ap₂ _+_ (*-commutative x z) (*-commutative y z) ⟩
  z * x + z * y ∎

*-associative : (x y z : Nat) → (x * y) * z ≡ x * (y * z)
*-associative zero y z = refl
*-associative (suc x) y z =
  (y + x * y) * z     ≡⟨ *-distrib-+ʳ y (x * y) z ⟩
  y * z + (x * y) * z ≡⟨ ap₂ _+_ refl (*-associative x y z) ⟩
  y * z + x * (y * z) ∎
```

## Discreteness

A more interesting property of the natural numbers is that they are
_discrete_, i.e. there is a program that tells whether two naturals are
equal or not:

```agda
zero≠suc : {n : Nat} → zero ≡ suc n → ⊥
zero≠suc path = subst distinguish path tt where
  distinguish : Nat → Type
  distinguish zero = ⊤
  distinguish (suc x) = ⊥

suc-inj : {x y : Nat} → suc x ≡ suc y → x ≡ y
suc-inj = ap pred where
  pred : Nat → Nat
  pred (suc x) = x
  pred zero = zero

Discrete-Nat : Discrete Nat
Discrete-Nat zero zero = yes refl
Discrete-Nat zero (suc y) = no λ zero≡suc → absurd (zero≠suc zero≡suc)
Discrete-Nat (suc x) zero = no λ suc≡zero → absurd (zero≠suc (sym suc≡zero))
Discrete-Nat (suc x) (suc y) with Discrete-Nat x y
... | yes x≡y = yes (ap suc x≡y)
... | no ¬x≡y = no λ sucx≡sucy → ¬x≡y (suc-inj sucx≡sucy)
```

[Hedberg's theorem] implies that `Nat`{.Agda} is a [set].

[Hedberg's theorem]: agda://1Lab.HLevel.Sets#Discrete→isSet
[set]: agda://1Lab.HLevel#isSet

```agda
isSet-Nat : isSet Nat
isSet-Nat = Discrete→isSet Discrete-Nat
```

## Ordering

We define `_≤_`{.Agda} by recursion:

```agda
_≤_ : Nat → Nat → Type
zero ≤ zero = ⊤
zero ≤ suc y = ⊤
suc x ≤ zero = ⊥
suc x ≤ suc y = x ≤ y
```

Then we can prove it is reflexive, transitive and antisymmetric, making
it into a partial order:

```agda
≤-refl : (x : Nat) → x ≤ x
≤-refl zero = tt
≤-refl (suc x) = ≤-refl x

0≤x : (x : Nat) → zero ≤ x
0≤x zero = tt
0≤x (suc x) = tt

≤-trans : (x y z : Nat) → x ≤ y → y ≤ z → x ≤ z
≤-trans zero zero zero _ _          = tt
≤-trans zero zero (suc z) _ _       = tt
≤-trans zero (suc y) z p q          = 0≤x z
≤-trans (suc x) (suc y) (suc z) p q = ≤-trans x y z p q

≤-antisym : (x y : Nat) → x ≤ y → y ≤ x → x ≡ y
≤-antisym zero zero p q = refl
≤-antisym (suc x) (suc y) p q = ap suc (≤-antisym x y p q)

≤-prop : (x y : Nat) → isProp (x ≤ y)
≤-prop zero zero p q = refl
≤-prop zero (suc y) p q = refl
≤-prop (suc x) (suc y) p q = ≤-prop x y p q

≤-PartialOrder : isPartialOrder _≤_
≤-PartialOrder .fst .isPreorder.reflexive {x} = ≤-refl x
≤-PartialOrder .fst .isPreorder.transitive {x} {y} {z} = ≤-trans x y z
≤-PartialOrder .fst .isPreorder.propositional {x} {y} = ≤-prop x y
≤-PartialOrder .snd {x} {y} = ≤-antisym x y
```

Furthermore, this is a total order:

```agda
≤-flip : (x y : Nat) → (x ≤ y → ⊥) → y ≤ x
≤-flip zero zero ¬x≤y = tt
≤-flip zero (suc y) ¬x≤y = ¬x≤y tt
≤-flip (suc x) zero ¬x≤y = tt
≤-flip (suc x) (suc y) ¬x≤y = ≤-flip x y ¬x≤y

≤-dec : (x y : Nat) → Dec (x ≤ y)
≤-dec zero zero = yes tt
≤-dec zero (suc y) = yes tt
≤-dec (suc x) zero = no (λ z → z)
≤-dec (suc x) (suc y) = ≤-dec x y
```