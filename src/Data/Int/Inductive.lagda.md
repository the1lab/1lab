```
open import Data.Nat
open import 1Lab.Type.Dec
open import 1Lab.Equiv
open import 1Lab.Path
open import 1Lab.Type

module Data.Int.Inductive where
```

# Inductive Integers

The **inductive integers** (or **built-in integers**) are the type
generated by the two constructors `pos`{.Agda} and `negsuc`{.Agda}, as
below, but without the primes:

```
module _ where private
  data Int' : Type where
    pos'    : Nat → Int'
    negsuc' : Nat → Int'
```

This type is important to have around because it is the type of integers
that Agda privileges as a built-in:

```
open import Agda.Builtin.Int public
```

As the names indicate, these constructors are meant to represent a
`pos`{.Agda}itive integer, and the `negation of a successor`{.Agda
ident=negsuc} of a natural number, i.e. `negsuc`{.Agda} is the map
taking $n$ to $-(n + 1)$.

```agda
_ℕ-_ : Nat → Nat → Int
x     ℕ- zero  = pos x
zero  ℕ- suc y = negsuc y
suc x ℕ- suc y = x ℕ- y
```

We can decide equality of two `Int'`{.Agda}s by `comparing`{.Agda
ident=Discrete-Nat} their underlying naturals when the constructors
match (i.e. `pos`{.Agda}/`pos`{.Agda} or
`negsuc`{.Agda}/`negsuc`{.Agda}):

```agda
Discrete-Int : Discrete Int
Discrete-Int (pos x) (pos y) with Discrete-Nat x y
... | yes p = yes (ap pos p)
... | no ¬p = no λ path → ¬p (ap (λ { (pos x) → x ; (negsuc _) → zero }) path)

Discrete-Int (negsuc x) (negsuc y) with Discrete-Nat x y
... | yes p = yes (ap negsuc p)
... | no ¬p = no λ path → ¬p (ap (λ { (negsuc x) → x ; (pos _) → zero }) path)
```

And in case the constructors are mismatched, there can be no path
between them:

```agda
Discrete-Int (pos x) (negsuc y) =
  no λ path → subst (λ { (pos x) → ⊤ ; (negsuc _) → ⊥ }) path tt
Discrete-Int (negsuc x) (pos y) =
  no λ path → subst (λ { (pos x) → ⊥ ; (negsuc _) → ⊤ }) path tt
```

The integers are characterised as being the free type with an
equivalence. This equivalence is the successor function:

```
sucInt : Int → Int
sucInt (pos n)          = pos (suc n)
sucInt (negsuc zero)    = pos zero
sucInt (negsuc (suc n)) = negsuc n

predInt : Int → Int
predInt (pos zero)    = negsuc zero
predInt (pos (suc n)) = pos n
predInt (negsuc n)    = negsuc (suc n)

sucPred : (x : Int) → sucInt (predInt x) ≡ x
sucPred (pos zero) = refl
sucPred (pos (suc x)) = refl
sucPred (negsuc x) = refl

predSuc : (x : Int) → predInt (sucInt x) ≡ x
predSuc (pos x) = refl
predSuc (negsuc zero) = refl
predSuc (negsuc (suc x)) = refl

sucEquiv : Int ≃ Int
sucEquiv = Iso→Equiv (sucInt , iso predInt sucPred predSuc)
```
