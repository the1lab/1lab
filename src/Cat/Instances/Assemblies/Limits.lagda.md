<!--
```agda
open import Cat.Diagram.Limit.Finite
open import Cat.Instances.Assemblies
open import Cat.Diagram.Equaliser
open import Cat.Diagram.Terminal
open import Cat.Diagram.Product
open import Cat.Prelude

open import Data.Partial.Total
open import Data.Partial.Base
open import Data.Vec.Base using ([] ; _âˆ·_)

open import Realisability.PCA

import Realisability.Data.Pair
import Realisability.PCA.Sugar
import Realisability.Base
```
-->

```agda
module Cat.Instances.Assemblies.Limits {â„“A} (ğ”¸ : PCA â„“A) where
```

<!--
```agda
open Realisability.Data.Pair ğ”¸
open Realisability.PCA.Sugar ğ”¸
open Realisability.Base ğ”¸

open is-equaliser
open is-product
open Equaliser
open Terminal
open Product

private variable
  â„“ â„“' : Level
  X Y Z : Assembly ğ”¸ â„“
```
-->

# Finite limits of assemblies

We can define [[finite limits]] in a category of [[assemblies]] over a
[[partial combinatory algebra]] $\bA$ using the encoding of [[pairs in a
PCA]].

:::{.definition #product-assembly}
The [[product]] of a pair of assemblies has underlying set the product
of their underlying sets, and the realisability relation $e \Vdash (x ,
y)$ is generated by
$$
\tt{pair}\, \sf{x}\, \sf{y} \Vdash (x , y)
$$
whenever $\sf{x} \Vdash x$ and $\sf{y} \Vdash y$.
:::

```agda
_Ã—Asm_ : Assembly ğ”¸ â„“ â†’ Assembly ğ”¸ â„“' â†’ Assembly ğ”¸ (â„“ âŠ” â„“')
(X Ã—Asm Y) .Ob         = âŒ X âŒŸ Ã— âŒ Y âŒŸ
(X Ã—Asm Y) .has-is-set = hlevel 2

(X Ã—Asm Y) .realisers (x , y) = record where
  mem p = elÎ© $
    Î£[ a âˆˆ â†¯ âŒ ğ”¸ âŒŸ ] Î£[ b âˆˆ â†¯ âŒ ğ”¸ âŒŸ ]
      p â‰¡ `pair â‹† a â‹† b Ã— [ X ] a âŠ© x Ã— [ Y ] b âŠ© y

  def : {a : â†¯ âŒ ğ”¸ âŒŸ} â†’ a âˆˆ mem â†’ âŒ a âŒŸ
  def = rec! Î» a b p rx ry â†’
    subst âŒ_âŒŸ (sym p) (`pairâ†“â‚‚ (X .def rx) (Y .def ry))
```

Of course, every pair is realised because both the first and second
components have realisers.

```agda
(X Ã—Asm Y) .realised (x , y) = do
  pxrx â† X .realised x
  pyry â† Y .realised y
  let
    (px , rx) = pxrx
    (py , ry) = pyry
  inc (`pair â‹† px â‹† py , inc (px , py , refl , rx , ry))
```

The first projection, second projection, and pairing maps are realised
by their respective programs, `` `fst ``{.Agda}, `` `snd ``{.Agda} and
`` `pair ``{.Agda}. Since equality of assembly maps is at the level of
the underlying set-functions, these satisfy the universal property by
trivial computations.

```agda
Ï€â‚Asm : Assembly-hom (X Ã—Asm Y) X
Ï€â‚Asm {X = X} {Y = Y} = to-assembly-hom record where
  map (x , _)    = x
  realiser       = `fst
  tracks {a = a} = elim! Î» p q Î± rx ry â†’ substâŠ© X rx $
    `fst â‹† a                â‰¡âŸ¨ ap (`fst â‹†_) Î± âŸ©
    `fst â‹† (`pair â‹† p â‹† q)  â‰¡âŸ¨ `fst-Î² (X .def rx) (Y .def ry) âŸ©
    p                       âˆ

Ï€â‚‚Asm : Assembly-hom (X Ã—Asm Y) Y
Ï€â‚‚Asm {X = X} {Y = Y} = to-assembly-hom record where
  map (_ , x)    = x
  realiser       = `snd
  tracks {a = a} = elim! Î» p q Î± rx ry â†’ substâŠ© Y ry $
    ap (`snd â‹†_) Î± âˆ™ `snd-Î² (X .def rx) (Y .def ry)

âŸ¨_,_âŸ©Asm : Assembly-hom Z X â†’ Assembly-hom Z Y â†’ Assembly-hom Z (X Ã—Asm Y)
âŸ¨_,_âŸ©Asm {Z = Z} f g = record where
  map x = f Â· x , g Â· x

  tracked = do
    rf â† f .tracked
    rg â† g .tracked
    inc record where
      realiser = val âŸ¨ x âŸ© (rf `Â· x `, rg `Â· x)

      tracks {a = a} qx = inc
        ( rf â‹† a , rg â‹† a , abs-Î² _ _ (a , Z .def qx)
        , rf .tracks qx , rg .tracks qx )
```

<!--
```agda
Assemblies-products : has-products (Assemblies ğ”¸ â„“)
Assemblies-products X Y .apex = X Ã—Asm Y
Assemblies-products X Y .Ï€â‚ = Ï€â‚Asm
Assemblies-products X Y .Ï€â‚‚ = Ï€â‚‚Asm
Assemblies-products X Y .has-is-product .âŸ¨_,_âŸ© f g = âŸ¨ f , g âŸ©Asm
Assemblies-products X Y .has-is-product .Ï€â‚âˆ˜âŸ¨âŸ© = ext Î» _ â†’ refl
Assemblies-products X Y .has-is-product .Ï€â‚‚âˆ˜âŸ¨âŸ© = ext Î» _ â†’ refl
Assemblies-products X Y .has-is-product .unique p q = ext Î» a â†’ p Â·â‚š a ,â‚š q Â·â‚š a
```
-->

## The terminal assembly

The terminal assembly has the unit type as its underlying set, and we
let any $\sf{x} \Vdash \tt{tt}$. Alternatively, we could have defined
the terminal assembly so an arbitrary choice of element $\sf{x} : \bA$
realises the point, and the terminating map `!Asm`{.Agda} would be
tracked by the constant function with value $\sf{x}$.

```agda
âŠ¤Asm : Assembly ğ”¸ â„“
âŠ¤Asm .Ob          = Lift _ âŠ¤
âŠ¤Asm .has-is-set  = hlevel 2
âŠ¤Asm .realisers _ = defineds
âŠ¤Asm .realised  _ = inc (val âŸ¨ x âŸ© x)

!Asm : Assembly-hom X (âŠ¤Asm {â„“})
!Asm {X = X} = to-assembly-hom record where
  map    _  = lift tt
  realiser  = val âŸ¨ x âŸ© x
  tracks ha = subst âŒ_âŒŸ (sym (abs-Î² _ [] (_ , X .def ha))) (X .def ha)
```

<!--
```agda
Assemblies-terminal : Terminal (Assemblies ğ”¸ â„“)
Assemblies-terminal .top = âŠ¤Asm
Assemblies-terminal .hasâŠ¤ X .centre  = !Asm
Assemblies-terminal .hasâŠ¤ X .paths x = ext Î» _ â†’ refl
```
-->

## Equalisers

The [[equaliser]] of a pair of assembly maps $f, g : X \to Y$ has
underlying set the equaliser of $f$ and $g$, i.e. the type
$$
\sum_{x : X} f(x) = g(x)
$$;
the realisability relation is directly inherited from the domain,
and the equalising map is (at the level of types) the first projection
function, realised by the identity program.

```agda
Equ-asm : (f g : Assembly-hom X Y) â†’ Assembly ğ”¸ _
Equ-asm {X = X} f g .Ob = Î£[ x âˆˆ X ] (f Â· x â‰¡ g Â· x)
Equ-asm {X = X} f g .has-is-set = hlevel 2
Equ-asm {X = X} f g .realisers (x , _) = X .realisers x
Equ-asm {X = X} f g .realised  (x , _) = X .realised x

Assemblies-equalisers : has-equalisers (Assemblies ğ”¸ â„“)
Assemblies-equalisers f g .apex = Equ-asm f g
Assemblies-equalisers {a = A} f g .equ = to-assembly-hom record where
  map (x , _) = x
  realiser    = val âŸ¨ x âŸ© x
  tracks ha   = substâŠ© A ha (abs-Î² _ [] (_ , A .def ha))
Assemblies-equalisers f g .has-is-eq .equal = ext Î» x p â†’ p
```

The universal map $u : W \to \operatorname{Eq}(f,g)$ into the equaliser
given by some $e : W \to X$ differs from $e$ only at the level of sets,
so any realiser of $e$ is also a realiser of $u$.

```agda
Assemblies-equalisers f g .has-is-eq .universal {e' = e'} p =
  record where
    map x  = e' Â· x , ap map p Â· x
    tracked = do
      et â† e' .tracked
      inc record { [_]_âŠ¢_ et }

Assemblies-equalisers f g .has-is-eq .factors  = ext Î» _ â†’ refl
Assemblies-equalisers f g .has-is-eq .unique p = ext Î» a â†’ Î£-prop-path! (p Â·â‚š a)

Assemblies-finite-limits : Finitely-complete (Assemblies ğ”¸ â„“)
Assemblies-finite-limits = with-equalisers _
  Assemblies-terminal
  Assemblies-products
  Assemblies-equalisers
```
