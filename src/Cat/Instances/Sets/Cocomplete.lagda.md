<!--
```agda
open import Cat.Diagram.Coproduct.Indexed
open import Cat.Instances.Sets.Complete
open import Cat.Diagram.Colimit.Base
open import Cat.Diagram.Initial
open import Cat.Prelude
```
-->

```agda
module Cat.Instances.Sets.Cocomplete where
```

# Sets is cocomplete

<!--
```agda
open Initial
```
-->

Before proving that the [category of sets] is [cocomplete], as a warm-up
exercise, we prove that the category of sets admits [indexed
coproducts], and furthermore, that these are [disjoint]: all of the
coproduct inclusions are monomorphisms, and distinct inclusions have
initial images. This will be illustrative of a minor sticking point that
will come up in the construction of arbitrary colimits.

[indexed coproducts]: Cat.Diagram.Coproduct.Indexed.html
[cocomplete]: Cat.Diagram.Colimit.Base.html#cocompleteness
[category of sets]: Cat.Instances.Sets.html
[disjoint]: Cat.Diagram.Coproduct.Indexed.html#disjoint-coproducts

```agda
Sets-has-coproducts : ∀ {κ ℓ} → has-indexed-coproducts (Sets (κ ⊔ ℓ)) κ
Sets-has-coproducts {κ} {ℓ} {I = I} F = coprod where
```

The coproduct of the family $F : I \to \Sets$ is given by the type $\sum
F$. However, this type is in general _not a set_! Consider a family of
sets indexed by [the circle]. Its total space will, by necessity, be a
[groupoid] rather than a set.

[the circle]: Homotopy.Space.Circle.html
[groupoid]: 1Lab.HLevel.html#is-groupoid

However, we can always [truncate] the sum down to a set, and it turns
out that this truncation _does_ serve as a coproduct of the family _in
the category of sets_. The point here is that, since the objects of
$\Sets$ are.. well, sets, they can't have any interesting paths, _by
definition_. A grim slogan: In the category of Sets, nobody can hear
your paths scream.

[truncate]: Data.Set.Truncation.html

```agda
  sum : Type (κ ⊔ ℓ)
  sum = Σ[ i ∈ I ] ∣ F i ∣

  open Indexed-coproduct
  open is-indexed-coproduct
  coprod : Indexed-coproduct (Sets _) F
  coprod .ΣF = el ∥ sum ∥₀ squash
  coprod .ι i x = inc (i , x)
  coprod .has-is-ic .match {Y = Y} f =
    ∥-∥₀-elim (λ _ → Y .is-tr) λ { (i , x) → f i x } {- 1 -}
  coprod .has-is-ic .commute = refl
  coprod .has-is-ic .unique {Y = Y} f p = funext
    (∥-∥₀-elim (λ _ → is-prop→is-set (Y .is-tr _ _)) λ x → happly (p _) _)
```

Note that, in the construction of `match`{.Agda} above, we used the fact
that $Y$ (the common codomain of all the $f_i$) is a set to `eliminate
from the truncation`{.Agda ident=∥-∥₀-elim} --- by definition, $Y$ can't
tell that $\sum F$ might have had some extra paths we squashed away.

## Colimits

Perfectly dually to the construction of [limits in $\Sets$], rather than
taking the equaliser of a product, we take the [coequaliser] of a sum. The
same considerations about truncation level that apply for arbitrary
coproducts apply to arbitrary colimits: fortunately, the construction of
set-coequalisers already includes a truncation.

[limits in $\Sets$]: Cat.Instances.Sets.Complete.html
[coequaliser]: Data.Set.Coequaliser.html

```agda
Sets-is-cocomplete : ∀ {ι κ o} → is-cocomplete ι κ (Sets (ι ⊔ κ ⊔ o))
Sets-is-cocomplete {ι} {κ} {o} {J = D} F = to-colimit (to-is-colimit colim) where
  module D = Precategory D
  module F = Functor F
  open _=>_
  open make-is-colimit

  sum : Type _
  sum = Σ[ d ∈ D.Ob ] ∣ F.₀ d ∣

  rel : sum → sum → Type _
  rel (X , x) (Y , y) = Σ[ f ∈ D.Hom X Y ] (F.₁ f x ≡ y)
```

The precise coequaliser we take is the [quotient] of $\sum F$ by the
relation (generated by) identifying together all those points $(X, x)$
and $(Y, y)$ whenever there exists a map $(X \xto{f} Y) \in \cD$ such
that $F(f)(x) = y$.

[quotient]: Data.Set.Coequaliser.html#quotients

By the same truncation nonsense as above, we can apply `Coeq-rec`{.Agda}
to eliminate from our quotient to the coapex of any other cocone over
$F$; The family of maps $\psi$ respects the quotient essentially by
definition.

```agda
  univ : ∀ {A : Set (ι ⊔ κ ⊔ o)}
       → (eps : ∀ j → ∣ F.F₀ j ∣ → ∣ A ∣)
       → (∀ {x y} (f : D.Hom x y) → ∀ Fx → eps y (F.F₁ f Fx) ≡ eps x Fx)
       → sum / rel
       → ∣ A ∣
  univ {A} eps p =
    Coeq-rec (A .is-tr)
      (λ { (x , p) → eps x p })
      (λ { ((X , x) , (Y , y) , f , q) → sym (p f x) ∙ ap (eps _) q})

  colim : make-is-colimit F (el! (sum / rel))
  colim .ψ x p = inc (x , p)
  colim .commutes f = funext λ _ → sym (quot (f , refl))
  colim .universal {A} eps p x = univ {A} eps (λ f → happly (p f)) x
  colim .factors eps p = refl
  colim .unique {A} eps p other q = funext λ x →
    Coeq-elim-prop
      (λ x →  A .is-tr (other x) (univ {A} eps (λ f → happly (p f)) x))
      (λ x → happly (q (x .fst)) (x .snd))
      x
```

# Coproducts are disjoint

As a final lemma, we prove that coproducts in $\Sets$, as constructed
above, are disjoint. However, this does not apply to _arbitrary_
coproducts; To prove that the injections are monomorphisms, we require
that the indexing type be a set.

```agda
module _ {κ} {I : Set κ} {F : ∣ I ∣ → Set κ} where
  private module coprod = Indexed-coproduct (Sets-has-coproducts {ℓ = κ} F)

  Set-disjoint-coprods : is-disjoint-coproduct (Sets κ) {S = coprod.ΣF} F coprod.ι
  Set-disjoint-coprods = coprod where
    open is-disjoint-coproduct
    open is-indexed-coproduct
```

We already know that the coproduct is a coproduct (who would have
guessed, honestly) --- so it remains to show that the `injections are
monic`{.Agda ident=injections-are-monic}, the `summands intersect`{.Agda
ident=summands-intersect}, and the intersections of different summands
are empty. The intersections are cheap: Sets is [[finitely complete]], so
all pullbacks exist, in particular the pullback of $F_i \to \sum F \ot
F_j$.

```agda
    coprod : is-disjoint-coproduct _ _ _
    coprod .is-coproduct = coprod.has-is-ic
    coprod .summands-intersect i j = Sets-pullbacks _ _
```

To prove that the injections are monic, we use our assumption that the
family $F$ was indexed by a set: The sum $\sum F$ then is also a set, so
we can get it out from under the truncation in the definition of
coproduct.

```agda
    coprod .injections-are-monic _ g h path = funext go where abstract
      path' : Path (∀ c → Σ _ (λ x → ∣ F x ∣)) (λ c → _ , g c) (λ c → _ , h c)
      path' i c = ∥-∥₀-elim {B = λ _ → Σ _ (∣_∣ ⊙ F)} (λ x → hlevel!)
        (λ x → x) (path i c)

      q : ∀ {c} → ap fst (happly path' c) ≡ refl
      q = I .is-tr _ _ _ _

      go : ∀ c → g c ≡ h c
      go c = subst (λ e → PathP (λ i → ∣ F (e i) ∣) (g c) (h c)) q
        (ap snd (happly path' c))
```

The same thing happens in proving that different injections have
disjoint images: We must project out a path $i = j$ from a path $\|
(i,-) = (j,-) \|$ --- using that they are in a set to eliminate from the
truncation --- to prove $\bot$ using the assumption that $i ≠ j$.

```agda
    coprod .different-images-are-disjoint i j i≠j os = contr map uniq where
      map : Σ[ i ∈ ∣ F i ∣ ] Σ _ (λ x → _) → ∣ os ∣
      map (i , j , p) = absurd (i≠j (ap (∥-∥₀-elim (λ _ → I .is-tr) fst) p))

      uniq : ∀ x → map ≡ x
      uniq _ = funext λ where
        (_ , _ , p) → absurd (i≠j (ap (∥-∥₀-elim (λ _ → I .is-tr) fst) p))
```
<!--
```agda
Sets-initial : ∀ {ℓ} → Initial (Sets ℓ)
Sets-initial .Initial.bot = el! (Lift _ ⊥)
Sets-initial .Initial.has⊥ x .centre () 
Sets-initial .Initial.has⊥ x .paths _ = ext λ ()

```

-->
