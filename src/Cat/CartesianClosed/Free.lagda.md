<!--
```agda
open import Cat.Displayed.Diagram.Total.Exponential
open import Cat.Displayed.Diagram.Total.Terminal
open import Cat.Displayed.Diagram.Total.Product
open import Cat.CartesianClosed.Free.Signature
open import Cat.Displayed.Instances.Slice
open import Cat.Diagram.Exponential
open import Cat.Displayed.Section
open import Cat.Functor.Kan.Nerve
open import Cat.Diagram.Terminal
open import Cat.Diagram.Product
open import Cat.Instances.Slice
open import Cat.Displayed.Base
open import Cat.Functor.Base
open import Cat.Functor.Hom
open import Cat.Cartesian
open import Cat.Prelude

open import Data.Dec.Base

open import Meta.Invariant

import Cat.Instances.Presheaf.Exponentials as Pe
import Cat.Displayed.Instances.Gluing
import Cat.Instances.Presheaf.Limits as Pl
import Cat.Displayed.Reasoning
import Cat.Functor.Bifunctor as Bifunctor

open Slice-hom
open Functor
open _=>_
```
-->

```agda
module Cat.CartesianClosed.Free {ℓ} (S : Λ-Signature ℓ) where
```

# Free cartesian closed categories

<!--
```agda
open Λ-Signature S renaming (Ob to Node ; Hom to Edge)

data Mor : Ty → Ty → Type ℓ

private variable
  τ σ ρ : Ty
  f g h : Mor τ σ

infixr 20 _`∘_
infixr 19 _`,_
```
-->

We can define the [[free|free object]] [[Cartesian closed]] category on
a [[$\Lambda$-signature|lambda signature]] $\Sigma = (T, H)$ directly as
a higher inductive type. The objects of this category will be the types
over $T$, and the morphisms are generated by the minimal set of
operations and equations which defines a Cartesian closed category.

```agda
data Mor where
  `_    : ∀ {x y} → Edge x y → Mor x (` y)

  `id   : Mor σ σ
  _`∘_  : Mor σ ρ → Mor τ σ → Mor τ ρ

  `idr   : f `∘ `id ≡ f
  `idl   : `id `∘ f ≡ f
  `assoc : f `∘ g `∘ h ≡ (f `∘ g) `∘ h

  `!    : Mor τ `⊤
  `!-η  : (h : Mor τ `⊤) → `! ≡ h

  `π₁   : Mor (τ `× σ) τ
  `π₂   : Mor (τ `× σ) σ
  _`,_  : Mor τ σ → Mor τ ρ → Mor τ (σ `× ρ)

  `π₁β  : `π₁ `∘ (f `, g) ≡ f
  `π₂β  : `π₂ `∘ (f `, g) ≡ g
  `πη   : f ≡ (`π₁ `∘ f `, `π₂ `∘ f)

  `ev  : Mor ((τ `⇒ σ) `× τ) σ
  `ƛ   : Mor (τ `× σ) ρ → Mor τ (σ `⇒ ρ)

  `ƛβ : `ev `∘ (`ƛ f `∘ `π₁ `, `id `∘ `π₂) ≡ f
  `ƛη : f ≡ `ƛ (`ev `∘ (f `∘ `π₁ `, `id `∘ `π₂))

  squash : is-set (Mor τ σ)
```

<details>
<summary>We package all of these laws into the appropriate bundles in
this `<details>`{.html} tag.</summary>

```agda
instance
  H-Level-Mor : ∀ {x y n} → H-Level (Mor x y) (2 + n)
  H-Level-Mor = basic-instance 2 squash

module _ where
  open Precategory

  Free-ccc : Precategory ℓ ℓ
  Free-ccc .Ob          = Ty
  Free-ccc .Hom         = Mor
  Free-ccc .Hom-set _ _ = squash
  Free-ccc .id          = `id
  Free-ccc ._∘_         = _`∘_
  Free-ccc .idr   _     = `idr
  Free-ccc .idl   _     = `idl
  Free-ccc .assoc _ _ _ = `assoc

  open Cartesian-closed
  open is-exponential
  open Exponential
  open is-product
  open Terminal
  open Product

  Free-products : has-products Free-ccc
  Free-products a b .apex = a `× b
  Free-products a b .π₁ = `π₁
  Free-products a b .π₂ = `π₂
  Free-products a b .has-is-product .⟨_,_⟩ f g = f `, g
  Free-products a b .has-is-product .π₁∘⟨⟩ = `π₁β
  Free-products a b .has-is-product .π₂∘⟨⟩ = `π₂β
  Free-products a b .has-is-product .unique p q = `πη ∙ ap₂ _`,_ p q

  Free-terminal : Terminal Free-ccc
  Free-terminal .top    = `⊤
  Free-terminal .has⊤ x = contr `! `!-η

  open Cartesian-category using (products ; terminal)
  Free-cartesian : Cartesian-category Free-ccc
  Free-cartesian .products = Free-products
  Free-cartesian .terminal = Free-terminal

  Free-closed : Cartesian-closed Free-ccc Free-cartesian
  Free-closed .has-exp A B .B^A = A `⇒ B
  Free-closed .has-exp A B .ev = `ev
  Free-closed .has-exp A B .has-is-exp .ƛ = `ƛ
  Free-closed .has-exp A B .has-is-exp .commutes m = `ƛβ
  Free-closed .has-exp A B .has-is-exp .unique m' x = `ƛη ∙ ap `ƛ x

private module Syn = Cartesian-category Free-cartesian
```

</details>

Instead of phrasing the universal property as a form of *initiality*,
we'll state *induction* instead. While we could derive [[induction from
initiality]], stating the 'traditional' universal property for a free
CCC, this has a couple of issues when it comes to working in a
homotopical proof assistant.

Firstly, the categories we're using for the normalisation proof are not
[[*strict*|strict category]], so we do not have a proper 1-category of
models within which we could say that `Free-ccc`{.Agda} is [[initial]].
Even then, it is slightly unreasonable to expect Cartesian closed
functors to preserve the structure up to identity.

We could set up a [[bicategory]] of Cartesian closed categories,
functors, and natural transformations between them, but this would
result in a significantly more annoying normalisation result, saying
that every `Mor`{.Agda}phism is *isomorphic* to the inclusion of a
normal form.

Conversely, if we did require all the categories involved to be strict
(which would require exchanging the presheaf category for something like
a [[material set]]-valued presheaf category), having normal forms that
live in types *identical* to the inputs is still not good enough,
because now we either end up with a normal form that is only related to
the input over a `PathP`{.Agda}, or we introduce a `subst`{.Agda} that
would not compute in a useful way.

Stating an induction principle for `Ty`{.Agda} and `Mor`{.Agda} is
simply a much more sensible thing to do: we do not impose a strictness
condition on the categories we're eliminating into by requiring models
to live in a 1-category, and now the types guarantee that the results
are *definitionally* talking about the input types. However, since
`Mor`{.Agda} has quite a few constructors, the *inputs* to this
induction principle are... quite gnarly. We package them up using the
language of [[displayed categories]].

First, we require a displayed category $\cD \liesover
\thecat{Syn}_\Sigma$, which gives us not only the *motives* for
elimination, i.e. the types of the conclusions, but also the methods
(including the *equational* methods) for `` `id ``{.Agda} and `` _`∘_
``{.Agda}.

```agda
module
  elim {o' ℓ'} {D : Displayed Free-ccc o' ℓ'}
```

Next, $\cD$ must have [[total products]] over the Cartesian structure of
$\thecat{Syn}_\Sigma$. In non-displayed language, this says that the
[[total category]] $\int \cD$ has [[products]] and the projection
functor preserves them. But in displayed language, it says precisely
that we can put together product diagrams in $\cD$ which are displayed
over product diagrams in $\thecat{Syn}_\Sigma$. We also ask for a
[[total terminal object]] in $\cD$.

```agda
    (cart : Cartesian-over D Free-cartesian)
```

This makes $\cD$ into a Cartesian category *over* $\thecat{Syn}_\Sigma$,
which in turn enables us to talk about [[total exponential objects]] in
$\cD$.  Of course, these also provide methods we're lacking, so we must
also ask for these, making $\cD$ into a category `Cartesian closed
over`{.Agda ident=Cartesian-closed-over} $\thecat{Syn}_\Sigma$. Finally,
we can ask for an interpretation $f$ of the base types in $\cD$.

```agda
    (cco  : Cartesian-closed-over D cart Free-closed)
    (f : (x : Node) → D ʻ (` x))
  where
```

<!--
```agda
  open Cartesian-closed-over D cart {Free-closed} cco
  open Cat.Displayed.Reasoning D
  open Cartesian-over cart
```
-->

This lets us construct a section of the objects of $\cD$, i.e. a method
that turns any type $\tau$ into an object $S(\tau) \liesover \tau$.

```agda
  Ty-elim : (x : Ty) → D ʻ x
  Ty-elim `⊤       = top'
  Ty-elim (` x)    = f x
  Ty-elim (τ `× σ) = Ty-elim τ ⊗₀' Ty-elim σ
  Ty-elim (τ `⇒ σ) = [ Ty-elim τ , Ty-elim σ ]'
```

<details>
<summary>Since the base terms in a $\Lambda$-signature have an arbitrary
`Ty`{.Agda} as input (but a base type as output), we can only state the
type of our last method after defining `Ty-elim`{.Agda}. It is, however,
natural: we ask for a map $S(e) : S(\tau) \to_e f(y)$ lying over every
basic term $e$.

```agda
  base-method : Type _
  base-method = ∀ {x y} (e : Edge x y) → Hom[ ` e ] (Ty-elim x) (f y)

  private module _ (h : base-method) where
    go : ∀ {x y} (m : Mor x y) → Hom[ m ] (Ty-elim x) (Ty-elim y)
```

By a long and uninteresting case bash, we can extend
`base-method`{.Agda} to cover all of `Mor`{.Agda}.
</summary>

```agda
    go (` x)     = h x
    go `id       = id'
    go (f `∘ g) = go f ∘' go g

    go (`idr {f = f} i) = idr' (go f) i
    go (`idl {f = f} i) = idl' (go f) i
    go (`assoc {f = f} {g = g} {h = h} i) = assoc' (go f) (go g) (go h) i

    go `!         = !'
    go (`!-η e i) = !'-unique₂ {h = !'} {h' = go e} {p = `!-η e} i

    go `π₁        = π₁'
    go `π₂        = π₂'
    go (f `, g)   = ⟨ go f , go g ⟩'

    go (`π₁β {f = f} {g = g} i) = π₁∘⟨⟩' {f' = go f} {g' = go g} i
    go (`π₂β {f = f} {g = g} i) = π₂∘⟨⟩' {f' = go f} {g' = go g} i
    go `ev     = ev'
    go (`ƛ  e) = ƛ' (go e)
```

Note that the following equational cases need slight corrections (which
we are free to do because `Mor`{.Agda} is a [[set]]) between the path
constructors in `Mor`{.Agda} and the $\beta$/$\eta$ laws required for a
Cartesian closed category.

```agda
    go (`πη {f = f} i) = want i where
      have : PathP (λ i → Hom[ Syn.⟨⟩-unique refl refl i ] _ _) (go f) ⟨ π₁' ∘' go f , π₂' ∘' go f ⟩'
      have = ⟨⟩'-unique {other' = go f} refl refl

      want : PathP (λ i → Hom[ `πη i ] _ _) (go f) ⟨ π₁' ∘' go f , π₂' ∘' go f ⟩'
      want = cast[] have
    go (`ƛβ {f = f} i) = want i where
      want : PathP (λ i → Hom[ `ƛβ {f = f} i ] _ _) (ev' ∘' ⟨ ƛ' (go f) ∘' π₁' , id' ∘' π₂' ⟩') (go f)
      want = cast[] (commutes' (go f))
    go (`ƛη {f = f} i) = want i where
      want : PathP (λ i → Hom[ `ƛη {f = f} i ] _ _) (go f) (ƛ' (ev' ∘' ⟨ go f ∘' π₁' , id' ∘' π₂' ⟩'))
      want = cast[] (ƛ'-unique {p = refl} (go f) refl)

    go (squash x y p q i j) = is-set→squarep (λ i j → Hom[ squash x y p q i j ]-set (Ty-elim _) (Ty-elim _)) (λ i → go x) (λ i → go (p i)) (λ i → go (q i)) (λ i → go y) i j

  open Section
```

</details>

Induction for `Free-ccc`{.Agda} says that, if we have such a "displayed
Cartesian closed category" $\cD \liesover \thecat{Syn}_\Sigma$ and
interpretations of the base types and base terms, then $\cD$ has a
[[section|section of a displayed category]].

```agda
  Free-ccc-elim : base-method → Section D
  Free-ccc-elim h .S₀      = Ty-elim
  Free-ccc-elim h .S₁      = go h
  Free-ccc-elim h .S-id    = refl
  Free-ccc-elim h .S-∘ f g = refl
```

# Intensional syntax

Our objective is to prove that, if both the base types and base terms in
the [[lambda-signature]] $\Sigma$ have decidable equality, then so do
the objects and morphisms in $\thecat{Syn}_\Sigma$. As `Mor`{.Agda} is a
complicated higher-inductive type, this is essentially infeasible to do
'by hand' by a case bash, which works for ordinary indexed inductive
types because those have all disjoint constructors.

The strategy will instead be to show that `Mor`{.Agda} is a [[split
quotient]] of some type that we *can* write a case bash for. That is,
we'll write a *sound* normalisation procedure for `Mor`{.Agda}, which
(by construction) factors through some type that *has* decidable
equality.[^deceq] Note that since `Mor`{.Agda} is a quotient, and our
normalisation procedure is a function, completeness is automatic.

[^deceq]:
    The construction of the normalisation procedure does not depend on
    $\Sigma$ having decidable equality.

Factoring the construction through some intermediate type of normal
forms is also necessary to actually state normalisation to begin with:
soundness and completeness together imply that, if normalisation were
just an endofunction on `Mor`{.Agda}, it would be the identity.

Our notion of normal form is that of the simply-typed lambda calculus.
Note that despite `Mor`{.Agda} working over *types*, we will introduce a
notion of *context* to be used during the proof of normalisation. The
normal form of a map $m : \thecat{Syn}_\Sigma(\tau, \sigma)$ will then
live in $x : \tau \vdash_\rm{nf} e : \sigma$, i.e. it will inhabit the
context with a single variable typed the domain of $e$. This is because
normalisation for function types will involve *renamings*, and
implementing this correctly is easier if binders are separate from
products. Since we're working with simple types, contexts are just lists
of types. We also have the usual definition of variable as a pointer
into a nonempty context.

```agda
data Cx : Type ℓ where
  ∅   : Cx
  _,_ : Cx → Ty → Cx

private variable Γ Δ Θ : Cx

data Var : Cx → Ty → Type ℓ where
  stop : Var (Γ , τ) τ
  pop  : Var Γ τ → Var (Γ , σ) τ
```

The type of normal forms has a unique constructor for each type,[^ind]
and the arguments are essentially unsurprising in each case: There's
nothing to a normal form of the unit type, and a normal pair is a pair
of normal forms. For function types, we shift the domain into the
context. At base types, the normal forms are given by *neutral* terms.

[^ind]:
    We could thus define the type of normal forms by *recursion* on the
    type, rather than by induction, but we stick with the inductive
    definition to make pattern matching slightly more convenient.

<!--
```agda
data Nf : Cx → Ty → Type ℓ
data Ne : Cx → Ty → Type ℓ
```
-->

```agda
data Nf where
  lam  : Nf (Γ , τ) σ       → Nf Γ (τ `⇒ σ)
  pair : Nf Γ τ → Nf Γ σ    → Nf Γ (τ `× σ)
  unit :                      Nf Γ `⊤
  ne   : ∀ {x} → Ne Γ (` x) → Nf Γ (` x)
```

A neutral term is a variable, or an elimination form applied to another
neutral. The 'elimination form' for a base term is *also* application to
a normal form in the domain. For example, we can build a neutral of type
$\tau$ by projecting the first component from a neutral of type $\tau
\times \sigma$.

```agda
data Ne where
  var  : Var Γ τ                     → Ne Γ τ
  app  : Ne Γ (τ `⇒ σ)      → Nf Γ τ → Ne Γ σ
  hom  : ∀ {a b} → Edge a b → Nf Γ a → Ne Γ (` b)
  fstₙ : Ne Γ (τ `× σ)               → Ne Γ τ
  sndₙ : Ne Γ (τ `× σ)               → Ne Γ σ
```

We summarize neutrals and normals with a selection of some of our finest
"gammas and turnstiles", leaving implicit the translation from named
variables in the context (i.e. the judgement $x : \tau \in \Gamma$) to
de Bruijn indices.

::: mathpar
$$\frac{}{\Gamma \vdash_\rm{nf} \star : \top}$$

$$
\frac
  {\Gamma, x : \tau \vdash_\rm{nf} b : \sigma}
  {\Gamma \vdash_\rm{nf} (\lambda x.\ b) : \tau \to \sigma}
$$

$$
\frac
  {\Gamma \vdash_\rm{nf} a : \tau\quad
   \Gamma \vdash_\rm{nf} b : \sigma
  }
  {\Gamma \vdash_\rm{nf} (a, b) : \tau \times \sigma}
$$

$$
\frac
  {\Gamma \vdash_\rm{ne} x : \sf{t}}
  {\Gamma \vdash_\rm{nf} x : \sf{t}}
$$

$$
\frac{x : \tau \in \Gamma}{\Gamma \vdash_{ne} x : \tau}
$$

$$
\frac
  {\Gamma \vdash_\rm{ne} f : \tau \to \sigma\quad
   \Gamma \vdash_\rm{nf} x : \tau}
  {\Gamma \vdash_\rm{ne} f\, x : \sigma}
$$

$$
\frac
  {\sf{f} : \tau \to \sf{t} \in \Sigma\quad
   \Gamma \vdash_\rm{nf} x : \tau}
  {\Gamma \vdash_\rm{ne} \sf{f}\, x : \sf{t}}
$$

$$
\frac
  {\Gamma \vdash_\rm{ne} p : \tau \times \sigma}
  {\Gamma \vdash_\rm{ne} \operatorname{fst}(p) : \tau}
$$

$$
\frac
  {\Gamma \vdash_\rm{ne} p : \tau \times \sigma}
  {\Gamma \vdash_\rm{ne} \operatorname{snd}(p) : \sigma}
$$
:::

## Normalisation and presheaves

The key idea behind our normalisation algorithm, following Čubrić et.
al. [-@Cubric:normalisation], is to work in a category of presheaves
over the syntax $\thecat{Syn}_\Sigma$, which are a model of the same
$\Lambda$-theory $\Sigma$. We thus have a (Cartesian closed) functor
$[\yo] : \thecat{Syn}_\Sigma \to \psh(\thecat{Syn}_\Sigma)$ which is
defined in terms of the Cartesian closed structure, e.g. we have
definitional computation rules
$$
\begin{align*}
[\yo](\tau \times \sigma) &= [\yo](\tau) \times [\yo](\sigma) \\
[\yo](\tau \to \sigma)    &= [\yo](\sigma)^{[\yo](\tau)}
\end{align*}
$$

The elements of $[\yo](\tau)$ thus do not correspond directly to
morphisms in the base, but are instead a sort of $\eta$-long interaction
representation of $\lambda$-terms. Now since the [[Yoneda embedding]] is
a Cartesian closed functor, the universal property of
$\thecat{Syn}_\Gamma$ gives a natural isomorphism $\yo \cong [\yo]$.
Intensionally, round-tripping through this isomorphism has the effect of
replacing a map by its normal form, which can be noticed because (e.g.)
the elements of $[\yo](\tau \times \sigma)$ are actual pairs. However,
we can not observe this happening mathematically because, as mentioned
above, a map and its normal form in $\thecat{Syn}$ are identical.

We would like to factor this isomorphism through `Nf`{.Agda} above, but
`Nf`{.Agda} is not readily made into a presheaf on the entire syntax. We
instead pass to presheaves of a subcategory of the syntax for which this
is easily doable: the **renamings**, the smallest subcategory which is
closed under precomposition by $\pi_1 : \Gamma, \tau \to \Gamma$ and
under the functorial action
$$
(- \times \id)
  :   \thecat{Syn}_\Sigma(\Gamma,\Delta)
  \to \thecat{Syn}_\Sigma(\Gamma \times \tau, \Delta \times \tau)
$$, which is of course best defined as the inductive type `Ren`{.Agda},
which we use as the type of morphisms for the category `Rens`{.Agda}.

```agda
data Ren : Cx → Cx → Type ℓ where
  stop : Ren Γ Γ
  drop : Ren Γ Δ → Ren (Γ , τ) Δ
  keep : Ren Γ Δ → Ren (Γ , τ) (Δ , τ)
```

There is an evident embedding of $\thecat{Ren}_\Gamma$ back into
$\thecat{Syn}_\Gamma$, written out below, by interpreting the
constructors as the aforementioned categorical constructions (and
contexts by products). Moreover, this embedding is a Cartesian functor.

```agda
⟦_⟧ᶜ : Cx → Ty
⟦ ∅     ⟧ᶜ = `⊤
⟦ Γ , x ⟧ᶜ = ⟦ Γ ⟧ᶜ `× x

⟦_⟧ʳ : Ren Γ Δ → Mor ⟦ Γ ⟧ᶜ ⟦ Δ ⟧ᶜ
⟦ stop   ⟧ʳ = `id
⟦ drop r ⟧ʳ = ⟦ r ⟧ʳ `∘ `π₁
⟦ keep r ⟧ʳ = ⟦ r ⟧ʳ `∘ `π₁ `, `π₂
```

<details>
<summary>We then have to prove that all of these constructions are
[[sets]], since we will be using them to form precategories and
presheaves. This is bog-standard encode-decode stuff, and so it's
uncommented in this `<details>`{.Agda} block for space.

While we're here, we also prove that all these type formers preserve
decidability of equality.</summary>

```agda
private
  same-cx : Cx → Cx → Prop ℓ
  same-cx ∅       ∅ = el! (Lift _ ⊤)
  same-cx ∅       _ = el! (Lift _ ⊥)
  same-cx (Γ , τ) (Δ , σ) = el! (⌞ same-cx Γ Δ ⌟ × ⌞ same-ty τ σ ⌟)
  same-cx (Γ , τ) _       = el! (Lift _ ⊥)

  from-same-cx : ∀ Γ Γ' → ⌞ same-cx Γ Γ' ⌟ → Γ ≡ Γ'
  from-same-cx ∅       ∅        p = refl
  from-same-cx (Γ , x) (Γ' , y) p = ap₂ _,_ (from-same-cx Γ Γ' (p .fst)) (from-same-ty x y (p .snd))

  refl-same-cx : ∀ Γ → ⌞ same-cx Γ Γ ⌟
  refl-same-cx ∅       = lift tt
  refl-same-cx (Γ , x) = (refl-same-cx Γ) , (refl-same-ty x)

instance
  H-Level-Cx : ∀ {n} → H-Level Cx (2 + n)
  H-Level-Cx = basic-instance 2 $
    set-identity-system→hlevel
      (λ x y → ⌞ same-cx x y ⌟) refl-same-cx
      (λ x y → hlevel 1) from-same-cx

private
  same-ren
    : ∀ {Γ' Δ'} (p : ⌞ same-cx Γ Γ' ⌟) (q : ⌞ same-cx Δ Δ' ⌟)
    → Ren Γ Δ → Ren Γ' Δ' → Prop ℓ

  same-ren p q stop stop         = el! (Lift _ ⊤)
  same-ren p q (drop x) (drop y) = same-ren (p .fst) q x y
  same-ren p q (keep x) (keep y) = same-ren (p .fst) (q .fst) x y

  same-ren p q stop (drop y)     = el! (Lift _ ⊥)
  same-ren p q stop (keep y)     = el! (Lift _ ⊥)
  same-ren p q (drop x) stop     = el! (Lift _ ⊥)
  same-ren p q (drop x) (keep y) = el! (Lift _ ⊥)
  same-ren p q (keep x) stop     = el! (Lift _ ⊥)
  same-ren p q (keep x) (drop y) = el! (Lift _ ⊥)

  from-same-ren
    : ∀ {Γ Δ Γ' Δ'} (p : ⌞ same-cx Γ Γ' ⌟) (q : ⌞ same-cx Δ Δ' ⌟) x y
    → ⌞ same-ren p q x y ⌟
    → PathP (λ i → Ren (from-same-cx Γ Γ' p i) (from-same-cx Δ Δ' q i)) x y
  from-same-ren {Γ = Γ} {Γ' = Γ'} p q stop stop α =
    is-set→cast-pathp {x = Γ , Γ} {y = Γ' , Γ'} {from-same-cx _ _ p ,ₚ _} {_ ,ₚ _}
      (uncurry Ren) (hlevel 2) λ i → stop
  from-same-ren p q (drop x) (drop y) α = λ i → drop (from-same-ren _ _ x y α i)
  from-same-ren {Γ , τ} {Δ , τ} {Γ' , τ'} {Δ' , τ'} p q (keep x) (keep y) α =
    is-set→cast-pathp {x = _} {y = _} {from-same-cx _ _ (p .fst , q .snd) ,ₚ from-same-cx (Δ , τ) (Δ' , τ') q} {_ ,ₚ _}
      (uncurry Ren) (hlevel 2) λ i → keep (from-same-ren _ _ x y α i)

  refl-same-ren : ∀ {Γ Δ} (x : Ren Γ Δ) → ⌞ same-ren (refl-same-cx Γ) (refl-same-cx Δ) x x ⌟
  refl-same-ren stop     = lift tt
  refl-same-ren (drop x) = refl-same-ren x
  refl-same-ren (keep x) = refl-same-ren x

  same-var : ∀ {Γ' τ'} → ⌞ same-cx Γ Γ' ⌟ → ⌞ same-ty τ τ' ⌟ → Var Γ τ → Var Γ' τ' → Prop ℓ
  same-var q p stop    stop    = el! (Lift _ ⊤)
  same-var q p stop    _       = el! (Lift _ ⊥)
  same-var q p (pop x) (pop y) = same-var (q .fst) p x y
  same-var q p (pop x) _       = el! (Lift _ ⊥)

  from-same-var
    : ∀ {Γ' τ'} (p : ⌞ same-cx Γ Γ' ⌟) (q : ⌞ same-ty τ τ' ⌟) x y
    → ⌞ same-var p q x y ⌟
    → PathP (λ i → Var (from-same-cx Γ Γ' p i) (from-same-ty τ τ' q i)) x y
  from-same-var {Γ = Γ , τ} {τ = τ} {Γ' , τ'} {τ'} p q stop    stop    α =
    subst (λ e → PathP (λ i → Var (from-same-cx Γ Γ' (p .fst) i , from-same-ty τ τ' (p .snd) i) (from-same-ty τ τ' e i)) stop stop)
      {x = p .snd} {y = q} prop!
      λ i → stop
  from-same-var p q (pop x) (pop y) α = λ i → Var.pop (from-same-var (p .fst) q x y α i)

  same-ne  : ∀ {Γ' τ'} → ⌞ same-cx Γ Γ' ⌟ → ⌞ same-ty τ τ' ⌟ → Ne  Γ τ → Ne  Γ' τ' → Prop ℓ
  same-nf  : ∀ {Γ' τ'} → ⌞ same-cx Γ Γ' ⌟ → ⌞ same-ty τ τ' ⌟ → Nf  Γ τ → Nf  Γ' τ' → Prop ℓ

  same-nf q p unit       unit       = el! (Lift _ ⊤)
  same-nf q p unit       _          = el! (Lift _ ⊥)
  same-nf q p (lam x)    (lam y)    = same-nf (q , p .fst) (p .snd) x y
  same-nf q p (lam x)    _          = el! (Lift _ ⊥)
  same-nf q p (pair a b) (pair x y) = el! (⌞ same-nf q (p .fst) a x ⌟ × ⌞ same-nf q (p .snd) b y ⌟)
  same-nf q p (pair a b) _          = el! (Lift _ ⊥)
  same-nf q p (ne x)     (ne y)     = same-ne q p x y
  same-nf q p (ne x)     _          = el! (Lift _ ⊥)

  same-ne {Γ = Γ} {τ = τ} {Γ'} {τ'} q p (var x) (var y) = same-var q p x y
  same-ne _ _ (var x)   _         = el! (Lift _ ⊥)

  same-ne {Γ = Γ} q p (app {τ = τ} f x) (app {τ = σ} g y) = el! (
    Σ[ r ∈ same-ty τ σ ] (⌞ same-ne q (r , p) f g ⌟ × ⌞ same-nf q r x y ⌟))
  same-ne _ _ (app f x) _         = el! (Lift _ ⊥)

  same-ne q p (fstₙ {σ = τ} x) (fstₙ {σ = σ} y) = el! (
    Σ[ r ∈ same-ty τ σ ] ⌞ same-ne q (p , r) x y ⌟)
  same-ne _ _ (fstₙ x)  _         = el! (Lift _ ⊥)

  same-ne q p (sndₙ {τ = τ} x) (sndₙ {τ = σ} y) = el! (
    Σ[ r ∈ same-ty τ σ ] ⌞ same-ne q (r , p) x y ⌟)
  same-ne _ _ (sndₙ x)  _         = el! (Lift _ ⊥)

  same-ne q p (hom {a = τ} x a) (hom {a = σ} y b) = el! (
    Σ[ r ∈ same-ty τ σ ]
      ( PathP (λ i → Edge (from-same-ty τ σ r i) (p i)) x y
      × ⌞ same-nf q r a b ⌟
      ))
  same-ne _ _ (hom x a) _         = el! (Lift _ ⊥)

  from-same-ne
    : ∀ {Γ' τ'} (p : ⌞ same-cx Γ Γ' ⌟) (q : ⌞ same-ty τ τ' ⌟) x y
    → ⌞ same-ne p q x y ⌟
    → PathP (λ i → Ne (from-same-cx Γ Γ' p i) (from-same-ty τ τ' q i)) x y
  from-same-nf
    : ∀ {Γ' τ'} (p : ⌞ same-cx Γ Γ' ⌟) (q : ⌞ same-ty τ τ' ⌟) x y
    → ⌞ same-nf p q x y ⌟
    → PathP (λ i → Nf (from-same-cx Γ Γ' p i) (from-same-ty τ τ' q i)) x y

  from-same-ne p q (var x)   (var y)   α = λ i → var (from-same-var _ _ x y α i)
  from-same-ne p q (app f x) (app g y) α = λ i → app (from-same-ne _ _ f g (α .snd .fst) i) (from-same-nf _ _ x y (α .snd .snd) i)
  from-same-ne p q (fstₙ x)  (fstₙ y)  α = λ i → fstₙ (from-same-ne _ _ x y (α .snd) i)
  from-same-ne p q (sndₙ x)  (sndₙ y)  α = λ i → sndₙ (from-same-ne _ _ x y (α .snd) i)
  from-same-ne p q (hom f x) (hom g y) α = λ i → hom (α .snd .fst i) (from-same-nf _ _ x y (α .snd .snd) i)

  from-same-nf p q (lam x)    (lam y)    α = λ i → lam (from-same-nf _ _ x y α i)
  from-same-nf p q (pair a b) (pair x y) α = λ i → pair (from-same-nf _ _ a x (α .fst) i) (from-same-nf _ _ b y (α .snd) i)
  from-same-nf p q unit       unit       α = λ i → unit
  from-same-nf p q (ne x)     (ne y)     α = λ i → ne (from-same-ne p q x y α i)

  refl-same-var : (v : Var Γ τ) → ⌞ same-var (refl-same-cx Γ) (refl-same-ty τ) v v ⌟
  refl-same-var stop    = lift tt
  refl-same-var (pop v) = refl-same-var v

  refl-same-ne : (v : Ne Γ τ) → ⌞ same-ne (refl-same-cx Γ) (refl-same-ty τ) v v ⌟
  refl-same-nf : (v : Nf Γ τ) → ⌞ same-nf (refl-same-cx Γ) (refl-same-ty τ) v v ⌟
  refl-same-ne (var x)            = refl-same-var x
  refl-same-ne (app  {τ = τ} v x) = refl-same-ty τ , refl-same-ne v , refl-same-nf x
  refl-same-ne (fstₙ {σ = σ} v)   = refl-same-ty σ , refl-same-ne v
  refl-same-ne (sndₙ {τ = τ} v)   = refl-same-ty τ , refl-same-ne v
  refl-same-ne (hom  {a = τ} x v) =
      refl-same-ty τ
    , is-set→cast-pathp {p = refl} {q = from-same-ty τ τ (refl-same-ty τ)} (λ e → Edge e _) (hlevel 2)
        refl
    , refl-same-nf v

  refl-same-nf (lam x)    = refl-same-nf x
  refl-same-nf (pair a b) = refl-same-nf a , refl-same-nf b
  refl-same-nf unit       = lift tt
  refl-same-nf (ne x)     = refl-same-ne x

  from-same-var'
    : (x y : Var Γ τ)
    → ⌞ same-var (refl-same-cx Γ) (refl-same-ty τ) x y ⌟
    → x ≡ y
  from-same-var' {Γ} {τ} x y p = is-set→cast-pathp
    {x = Γ , τ} {y = Γ , τ} {_ ,ₚ _} {refl} (uncurry Var) (hlevel 2)
    (from-same-var (refl-same-cx Γ) (refl-same-ty τ) x y p)

  from-same-nf'
    : (x y : Nf Γ τ)
    → ⌞ same-nf (refl-same-cx Γ) (refl-same-ty τ) x y ⌟
    → x ≡ y
  from-same-nf' {Γ} {τ} x y p = is-set→cast-pathp
    {x = Γ , τ} {y = Γ , τ} {_ ,ₚ _} {refl} (uncurry Nf) (hlevel 2)
    (from-same-nf (refl-same-cx Γ) (refl-same-ty τ) x y p)

  from-same-ne'
    : (x y : Ne Γ τ)
    → ⌞ same-ne (refl-same-cx Γ) (refl-same-ty τ) x y ⌟
    → x ≡ y
  from-same-ne' {Γ} {τ} x y p = is-set→cast-pathp
    {x = Γ , τ} {y = Γ , τ} {_ ,ₚ _} {refl} (uncurry Ne) (hlevel 2)
    (from-same-ne (refl-same-cx Γ) (refl-same-ty τ) x y p)

instance
  H-Level-Ren : ∀ {n} → H-Level (Ren Γ Δ) (2 + n)
  H-Level-Ren {Γ} {Δ} = basic-instance 2 $
    set-identity-system→hlevel
      (λ x y → ⌞ same-ren (refl-same-cx Γ) (refl-same-cx Δ) x y ⌟)
      refl-same-ren
      (λ x y → hlevel 1)
      (λ x y p → is-set→cast-pathp {x = Γ , Δ} {y = Γ , Δ} {_ ,ₚ _} {refl} (uncurry Ren) (hlevel 2)
        (from-same-ren (refl-same-cx Γ) (refl-same-cx Δ) x y p))

  H-Level-Var : ∀ {n} → H-Level (Var Γ τ) (2 + n)
  H-Level-Var {Γ} {τ} = basic-instance 2 $ set-identity-system→hlevel
    (λ x y → ⌞ same-var (refl-same-cx Γ) (refl-same-ty τ) x y ⌟)
    refl-same-var (λ x y → hlevel 1) from-same-var'

  H-Level-Nf : ∀ {n} → H-Level (Nf Γ τ) (2 + n)
  H-Level-Nf {Γ} {τ} = basic-instance 2 $ set-identity-system→hlevel
    (λ x y → ⌞ same-nf (refl-same-cx Γ) (refl-same-ty τ) x y ⌟)
    refl-same-nf (λ x y → hlevel 1) from-same-nf'

  H-Level-Ne : ∀ {n} → H-Level (Ne Γ τ) (2 + n)
  H-Level-Ne {Γ} {τ} = basic-instance 2 $ set-identity-system→hlevel
    (λ x y → ⌞ same-ne (refl-same-cx Γ) (refl-same-ty τ) x y ⌟)
    refl-same-ne (λ x y → hlevel 1) from-same-ne'

module _ ⦃ _ : Discrete Node ⦄ ⦃ _ : ∀ {x y} → Discrete (Edge x y) ⦄ where
  private
    dec-same-ty : ∀ τ σ → Dec ⌞ same-ty τ σ ⌟
    dec-same-ty `⊤ σ with σ
    ... | `⊤      = yes (lift tt)
    ... | ` x     = no λ ()
    ... | x `× y  = no λ ()
    ... | x `⇒ y  = no λ ()
    dec-same-ty (` x) σ with σ
    ... | ` y     = auto
    ... | `⊤      = no λ ()
    ... | x `× y  = no λ ()
    ... | x `⇒ y  = no λ ()
    dec-same-ty (a `× b) σ with σ
    ... | x `× y  = Dec-× ⦃ dec-same-ty a x ⦄ ⦃ dec-same-ty b y ⦄
    ... | `⊤      = no λ ()
    ... | ` y     = no λ ()
    ... | x `⇒ y  = no λ ()
    dec-same-ty (a `⇒ b) σ with σ
    ... | x `⇒ y  = Dec-× ⦃ dec-same-ty a x ⦄ ⦃ dec-same-ty b y ⦄
    ... | `⊤      = no λ ()
    ... | ` y     = no λ ()
    ... | x `× y  = no λ ()

    dec-same-var
      : ∀ {Γ τ Γ' τ'}
      → (α : ⌞ same-cx Γ Γ' ⌟)
      → (β : ⌞ same-ty τ τ' ⌟)
      → (x : Var Γ τ) (y : Var Γ' τ') → Dec ⌞ same-var α β x y ⌟
    dec-same-var α β stop y with y
    ... | stop  = yes (lift tt)
    ... | pop _ = no λ ()
    dec-same-var α β (pop x) y with y
    ... | pop y = dec-same-var (α .fst) β x y
    ... | stop  = no λ ()

    dec-same-ne
      : ∀ {Γ τ Γ' τ'}
      → (α : ⌞ same-cx Γ Γ' ⌟)
      → (β : ⌞ same-ty τ τ' ⌟)
      → (x : Ne Γ τ) (y : Ne Γ' τ') → Dec ⌞ same-ne α β x y ⌟

    dec-same-nf
      : ∀ {Γ τ Γ' τ'}
      → (α : ⌞ same-cx Γ Γ' ⌟)
      → (β : ⌞ same-ty τ τ' ⌟)
      → (x : Nf Γ τ) (y : Nf Γ' τ') → Dec ⌞ same-nf α β x y ⌟

    dec-same-nf α β (lam x)    (lam y)    = dec-same-nf (α , β .fst) (β .snd) x y
    dec-same-nf α β (pair a b) (pair x y) = Dec-× ⦃ dec-same-nf α (β .fst) a x ⦄ ⦃ dec-same-nf α (β .snd) b y ⦄
    dec-same-nf α β unit       unit       = yes (lift tt)
    dec-same-nf α β (ne x)     (ne y)     = dec-same-ne α β x y

    dec-same-ne α β (var x) y with y
    ... | var y   = dec-same-var α β x y
    ... | app _ _ = no λ ()
    ... | fstₙ _  = no λ ()
    ... | sndₙ _  = no λ ()
    ... | hom _ _ = no λ ()
    dec-same-ne α β (app {τ = τ} f x) y with y
    ... | app {τ = σ} g y = Dec-Σ (hlevel 1) (dec-same-ty τ σ) λ γ → Dec-× ⦃ dec-same-ne α (γ , β) f g ⦄ ⦃ dec-same-nf α γ x y ⦄
    ... | var _   = no λ ()
    ... | fstₙ _  = no λ ()
    ... | sndₙ _  = no λ ()
    ... | hom _ _ = no λ ()
    dec-same-ne α β (hom {a = a} f x) y with y
    ... | hom {a = b} g y = Dec-Σ (hlevel 1) (dec-same-ty a b) λ γ → Dec-× ⦃ invmap to-pathp from-pathp auto ⦄ ⦃ dec-same-nf α γ x y ⦄
    ... | var _   = no λ ()
    ... | app _ _ = no λ ()
    ... | fstₙ _  = no λ ()
    ... | sndₙ _  = no λ ()
    dec-same-ne α β (fstₙ {σ = τ} x) y with y
    ... | fstₙ {σ = σ} y = Dec-Σ (hlevel 1) (dec-same-ty τ σ) λ γ → dec-same-ne α (β , γ) x y
    ... | var _   = no λ ()
    ... | app _ _ = no λ ()
    ... | sndₙ _  = no λ ()
    ... | hom _ _ = no λ ()
    dec-same-ne α β (sndₙ {τ = τ} x) y with y
    ... | sndₙ {τ = σ} y = Dec-Σ (hlevel 1) (dec-same-ty τ σ) λ γ → dec-same-ne α (γ , β) x y
    ... | var _   = no λ ()
    ... | app _ _ = no λ ()
    ... | fstₙ _  = no λ ()
    ... | hom _ _ = no λ ()

  instance
    Discrete-Ty : Discrete Ty
    Discrete-Ty .decide x y = invmap
      (from-same-ty x y) (λ p → subst (λ e → ⌞ same-ty x e ⌟) p (refl-same-ty x))
      (dec-same-ty x y)

    Discrete-Var : ∀ {Γ τ} → Discrete (Var Γ τ)
    Discrete-Var {Γ} {τ} .decide x y = invmap
      (from-same-var' x y)
      (λ p → subst (λ e → ⌞ same-var (refl-same-cx Γ) (refl-same-ty τ) x e ⌟) p (refl-same-var x))
      (dec-same-var (refl-same-cx Γ) (refl-same-ty τ) x y)

    Discrete-Ne  : ∀ {Γ τ} → Discrete (Ne  Γ τ)
    Discrete-Ne {Γ} {τ} .decide x y = invmap
      (from-same-ne' x y)
      (λ p → subst (λ e → ⌞ same-ne (refl-same-cx Γ) (refl-same-ty τ) x e ⌟) p (refl-same-ne x))
      (dec-same-ne (refl-same-cx Γ) (refl-same-ty τ) x y)

    Discrete-Nf  : ∀ {Γ τ} → Discrete (Nf  Γ τ)
    Discrete-Nf {Γ} {τ} .decide x y = invmap
      (from-same-nf' x y)
      (λ p → subst (λ e → ⌞ same-nf (refl-same-cx Γ) (refl-same-ty τ) x e ⌟) p (refl-same-nf x))
      (dec-same-nf (refl-same-cx Γ) (refl-same-ty τ) x y)
```

</details>

<details>
<summary>
Of course, we also have embeddings from variables, neutrals and normals
back into the syntax, which we will continue to write using decorated
"semantic brackets" `⟦_⟧`.

```agda
⟦_⟧ⁿ : Var Γ τ → Mor ⟦ Γ ⟧ᶜ τ
⟦_⟧ₙ : Nf  Γ τ → Mor ⟦ Γ ⟧ᶜ τ
⟦_⟧ₛ : Ne  Γ τ → Mor ⟦ Γ ⟧ᶜ τ
```

Due to a paucity of letters and unicode sub/superscripts, we went with
superscript `⟦_⟧ⁿ`{.Agda} for "name" interpreting variables, and
subscript `⟦_⟧ₛ` for "stuck" interpreting neutrals.
</summary>

```agda
⟦ stop  ⟧ⁿ = `π₂
⟦ pop x ⟧ⁿ = ⟦ x ⟧ⁿ `∘ `π₁

⟦ lam h    ⟧ₙ = `ƛ ⟦ h ⟧ₙ
⟦ pair a b ⟧ₙ = ⟦ a ⟧ₙ `, ⟦ b ⟧ₙ
⟦ ne x     ⟧ₙ = ⟦ x ⟧ₛ
⟦ unit     ⟧ₙ = `!

⟦ var x   ⟧ₛ = ⟦ x ⟧ⁿ
⟦ app f x ⟧ₛ = `ev `∘ (⟦ f ⟧ₛ `, ⟦ x ⟧ₙ)
⟦ fstₙ h  ⟧ₛ = `π₁ `∘ ⟦ h ⟧ₛ
⟦ sndₙ h  ⟧ₛ = `π₂ `∘ ⟦ h ⟧ₛ
⟦ hom s h ⟧ₛ = (` s) `∘ ⟦ h ⟧ₙ
```

</details>

<details>
<summary>Next, we equip renamings with the structure of a category; variables,
neutrals and normals get the structure of presheaves over the category
of renamings.

```agda
_∘ʳ_    : ∀ {Γ Δ Θ} → Ren Γ Δ → Ren Δ Θ → Ren Γ Θ
ren-var : ∀ {Γ Δ τ} → Ren Γ Δ → Var Δ τ → Var Γ τ
ren-ne  : ∀ {Γ Δ τ} → Ren Δ Γ → Ne  Γ τ → Ne  Δ τ
ren-nf  : ∀ {Γ Δ τ} → Ren Δ Γ → Nf  Γ τ → Nf  Δ τ
```

As is becoming traditional, the implementation is hidden in this
`<details>`{.html} block, and the verification of the myriad equational
laws is omitted from the page entirely. Many cases were bashed in the
making of this module.</summary>

```agda
stop   ∘ʳ ρ      = ρ
drop σ ∘ʳ ρ      = drop (σ ∘ʳ ρ)
keep σ ∘ʳ stop   = keep σ
keep σ ∘ʳ drop ρ = drop (σ ∘ʳ ρ)
keep σ ∘ʳ keep ρ = keep (σ ∘ʳ ρ)

ren-var stop     v       = v
ren-var (drop σ) v       = pop (ren-var σ v)
ren-var (keep σ) stop    = stop
ren-var (keep σ) (pop v) = pop (ren-var σ v)

ren-ne σ (var v)   = var  (ren-var σ v)
ren-ne σ (app f a) = app  (ren-ne σ f) (ren-nf σ a)
ren-ne σ (fstₙ a)  = fstₙ (ren-ne σ a)
ren-ne σ (sndₙ a)  = sndₙ (ren-ne σ a)
ren-ne σ (hom s a) = hom s (ren-nf σ a)

ren-nf σ (lam n)    = lam  (ren-nf (keep σ) n)
ren-nf σ (pair a b) = pair (ren-nf σ a) (ren-nf σ b)
ren-nf σ (ne x)     = ne   (ren-ne σ x)
ren-nf σ unit       = unit
```

</details>

<!--
```agda
∘ʳ-idr : (ρ : Ren Δ Θ) → ρ ∘ʳ stop ≡ ρ
∘ʳ-idr stop     = refl
∘ʳ-idr (drop ρ) = ap drop (∘ʳ-idr ρ)
∘ʳ-idr (keep ρ) = refl

∘ʳ-assoc
  : ∀ {w x y z} (f : Ren y z) (g : Ren x y) (h : Ren w x)
  → ((h ∘ʳ g) ∘ʳ f) ≡ (h ∘ʳ (g ∘ʳ f))
∘ʳ-assoc f        g        stop     = refl
∘ʳ-assoc f        g        (drop h) = ap drop (∘ʳ-assoc f g h)
∘ʳ-assoc f        stop     (keep h) = refl
∘ʳ-assoc f        (drop g) (keep h) = ap drop (∘ʳ-assoc f g h)
∘ʳ-assoc stop     (keep g) (keep h) = refl
∘ʳ-assoc (drop f) (keep g) (keep h) = ap drop (∘ʳ-assoc f g h)
∘ʳ-assoc (keep f) (keep g) (keep h) = ap keep (∘ʳ-assoc f g h)

ren-⟦⟧ⁿ : (ρ : Ren Δ Γ) (v : Var Γ τ) → ⟦ ren-var ρ v ⟧ⁿ ≡ ⟦ v ⟧ⁿ `∘ ⟦ ρ ⟧ʳ
ren-⟦⟧ₛ : (ρ : Ren Δ Γ) (t : Ne Γ τ)  → ⟦ ren-ne ρ t  ⟧ₛ ≡ ⟦ t ⟧ₛ `∘ ⟦ ρ ⟧ʳ
ren-⟦⟧ₙ : (ρ : Ren Δ Γ) (t : Nf Γ τ)  → ⟦ ren-nf ρ t  ⟧ₙ ≡ ⟦ t ⟧ₙ `∘ ⟦ ρ ⟧ʳ

ren-⟦⟧ⁿ stop v           = Syn.intror refl
ren-⟦⟧ⁿ (drop ρ) v       = Syn.pushl (ren-⟦⟧ⁿ ρ v)
ren-⟦⟧ⁿ (keep ρ) stop    = sym (Syn.π₂∘⟨⟩) -- sym (Syn.π₂∘⟨⟩ ∙ Syn.idl _)
ren-⟦⟧ⁿ (keep ρ) (pop v) = Syn.pushl (ren-⟦⟧ⁿ ρ v) ∙ sym (Syn.pullr Syn.π₁∘⟨⟩)

ren-⟦⟧ₛ ρ (var x) = ren-⟦⟧ⁿ ρ x
ren-⟦⟧ₛ ρ (app f x) = ap₂ _`∘_ refl
  (ap₂ _`,_ (ren-⟦⟧ₛ ρ f) (ren-⟦⟧ₙ ρ x) ∙ sym (Syn.⟨⟩∘ _))
  ∙ Syn.pulll refl
ren-⟦⟧ₛ ρ (fstₙ t)  = Syn.pushr (ren-⟦⟧ₛ ρ t)
ren-⟦⟧ₛ ρ (sndₙ t)  = Syn.pushr (ren-⟦⟧ₛ ρ t)
ren-⟦⟧ₛ ρ (hom x a) = Syn.pushr (ren-⟦⟧ₙ ρ a)

ren-⟦⟧ₙ ρ (lam t) =
    ap `ƛ (ren-⟦⟧ₙ (keep ρ) t)
  ∙ sym (Cartesian-closed.unique Free-closed _ (ap₂ _`∘_ refl rem₁ ∙ Syn.pulll `ƛβ ∙ ap₂ _`∘_ refl (ap₂ _`,_ refl `idl)))
  where
  rem₁ : (⟦ lam t ⟧ₙ `∘ ⟦ ρ ⟧ʳ) Syn.⊗₁ `id ≡ (⟦ lam t ⟧ₙ Syn.⊗₁ `id) `∘ ⟦ ρ ⟧ʳ Syn.⊗₁ `id
  rem₁ = Bifunctor.first∘first Syn.×-functor

ren-⟦⟧ₙ ρ (pair a b) = ap₂ _`,_ (ren-⟦⟧ₙ ρ a) (ren-⟦⟧ₙ ρ b) ∙ sym (Syn.⟨⟩∘ _)
ren-⟦⟧ₙ ρ (ne x) = ren-⟦⟧ₛ ρ x
ren-⟦⟧ₙ ρ unit   = `!-η _

ren-⟦⟧ʳ : ∀ {Γ Δ Θ} (f : Ren Γ Δ) (g : Ren Δ Θ) → ⟦ f ∘ʳ g ⟧ʳ ≡ ⟦ g ⟧ʳ `∘ ⟦ f ⟧ʳ
ren-⟦⟧ʳ stop     g        = sym `idr
ren-⟦⟧ʳ (drop f) g        = Syn.pushl (ren-⟦⟧ʳ f g)
ren-⟦⟧ʳ (keep f) stop     = sym `idl
ren-⟦⟧ʳ (keep f) (drop g) = Syn.pushl (ren-⟦⟧ʳ f g) ∙ sym (Syn.pullr `π₁β)
ren-⟦⟧ʳ (keep f) (keep g) = sym (Syn.⟨⟩-unique (Syn.pulll `π₁β ∙ Syn.pullr `π₁β ∙ Syn.pulll (sym (ren-⟦⟧ʳ f g))) (Syn.pulll `π₂β ∙ `π₂β))


ren-var-∘ʳ : ∀ {Γ Δ Θ} (ρ : Ren Γ Δ) (σ : Ren Δ Θ) (x : Var Θ τ) → ren-var (ρ ∘ʳ σ) x ≡ ren-var ρ (ren-var σ x)
ren-var-∘ʳ ρ        stop     x       = ap (λ e → ren-var e x) (∘ʳ-idr ρ)
ren-var-∘ʳ stop     (drop σ) x       = refl
ren-var-∘ʳ (drop ρ) (drop σ) x       = ap pop (ren-var-∘ʳ ρ (drop σ) x)
ren-var-∘ʳ (keep ρ) (drop σ) x       = ap pop (ren-var-∘ʳ ρ σ x)
ren-var-∘ʳ stop     (keep σ) x       = refl
ren-var-∘ʳ (drop ρ) (keep σ) x       = ap pop (ren-var-∘ʳ ρ (keep σ) x)
ren-var-∘ʳ (keep ρ) (keep σ) stop    = refl
ren-var-∘ʳ (keep ρ) (keep σ) (pop x) = ap pop (ren-var-∘ʳ ρ σ x)

ren-nf-∘ʳ : ∀ {Γ Δ Θ} (ρ : Ren Γ Δ) (σ : Ren Δ Θ) (x : Nf Θ τ) → ren-nf (ρ ∘ʳ σ) x ≡ ren-nf ρ (ren-nf σ x)
ren-ne-∘ʳ : ∀ {Γ Δ Θ} (ρ : Ren Γ Δ) (σ : Ren Δ Θ) (x : Ne Θ τ) → ren-ne (ρ ∘ʳ σ) x ≡ ren-ne ρ (ren-ne σ x)

ren-nf-∘ʳ ρ σ (lam x)    = ap lam (ren-nf-∘ʳ (keep ρ) (keep σ) x)
ren-nf-∘ʳ ρ σ (pair a b) = ap₂ pair (ren-nf-∘ʳ ρ σ a) (ren-nf-∘ʳ ρ σ b)
ren-nf-∘ʳ ρ σ unit       = refl
ren-nf-∘ʳ ρ σ (ne x)     = ap ne (ren-ne-∘ʳ ρ σ x)
ren-ne-∘ʳ ρ σ (var x)    = ap var (ren-var-∘ʳ ρ σ x)
ren-ne-∘ʳ ρ σ (app f x)  = ap₂ app (ren-ne-∘ʳ ρ σ f) (ren-nf-∘ʳ ρ σ x)
ren-ne-∘ʳ ρ σ (fstₙ x)   = ap fstₙ (ren-ne-∘ʳ ρ σ x)
ren-ne-∘ʳ ρ σ (sndₙ x)   = ap sndₙ (ren-ne-∘ʳ ρ σ x)
ren-ne-∘ʳ ρ σ (hom n x)  = ap (hom n) (ren-nf-∘ʳ ρ σ x)

data Keep : Cx → Cx → Type ℓ where
  stop : Keep Γ Γ
  keep : Keep Γ Δ → Keep (Γ , τ) (Δ , τ)

keep→ren : Keep Γ Δ → Ren Γ Δ
keep→ren stop     = stop
keep→ren (keep x) = keep (keep→ren x)

keep→ctx : Keep Γ Δ → Δ ≡ Γ
keep→ctx stop     = refl
keep→ctx (keep x) = ap₂ Cx._,_ (keep→ctx x) refl

ren-var-stop : (ρ : Keep Γ Δ) (x : Var Δ τ) → PathP (λ i → Var (keep→ctx ρ (~ i)) τ) (ren-var (keep→ren ρ) x) x
ren-var-stop stop     x       = refl
ren-var-stop (keep ρ) stop    i = stop
ren-var-stop (keep ρ) (pop x) i = pop (ren-var-stop ρ x i)

ren-nf-stop  : (ρ : Keep Γ Γ) (x : Nf Γ τ) → ren-nf (keep→ren ρ) x ≡ x
ren-ne-stop  : (ρ : Keep Γ Γ) (x : Ne Γ τ) → ren-ne (keep→ren ρ) x ≡ x

ren-nf-stop ρ (lam x)    = ap lam (ren-nf-stop (keep ρ) x)
ren-nf-stop ρ (pair a b) = ap₂ pair (ren-nf-stop ρ a) (ren-nf-stop ρ b)
ren-nf-stop ρ unit       = refl
ren-nf-stop ρ (ne x)     = ap ne (ren-ne-stop ρ x)

ren-ne-stop {τ = τ} ρ (var x)    = ap var
  ( from-pathp⁻ (ren-var-stop ρ x)
  ∙∙ ap (λ e → subst (λ x → Var x τ) e x) {x = keep→ctx ρ} {y = refl} prop!
  ∙∙ transport-refl _
  )

ren-ne-stop ρ (app f x)  = ap₂ app (ren-ne-stop ρ f) (ren-nf-stop ρ x)
ren-ne-stop ρ (fstₙ x)   = ap fstₙ (ren-ne-stop ρ x)
ren-ne-stop ρ (sndₙ x)   = ap sndₙ (ren-ne-stop ρ x)
ren-ne-stop ρ (hom x n)  = ap (hom x) (ren-nf-stop ρ n)
```
-->

<details>
<summary>Finally, one billion copattern matches make all of this
nonsense into actual categorical objects.</summary>

```agda
Rens : Precategory ℓ ℓ
Rens .Precategory.Ob          = Cx
Rens .Precategory.Hom         = Ren
Rens .Precategory.Hom-set X Y = hlevel 2

Rens .Precategory.id      = stop
Rens .Precategory._∘_ f g = g ∘ʳ f

Rens .Precategory.idr   f     = refl
Rens .Precategory.idl   f     = ∘ʳ-idr f
Rens .Precategory.assoc f g h = ∘ʳ-assoc f g h

Sem : Type _
Sem = ⌞ PSh ℓ Rens ⌟

Ren↪Ctx : Functor Rens Free-ccc
Ren↪Ctx .F₀      = ⟦_⟧ᶜ
Ren↪Ctx .F₁      = ⟦_⟧ʳ
Ren↪Ctx .F-id    = refl
Ren↪Ctx .F-∘ f g = ren-⟦⟧ʳ g f

Tm : Functor Free-ccc (PSh ℓ Rens)
Tm = Nerve Ren↪Ctx
```

<!--
```agda
open Pl ℓ Rens
open Pe Rens
private
  module Ren↪Ctx = Functor Ren↪Ctx
  module Sem = Cartesian-category {C = PSh ℓ Rens} PSh-cartesian
  module Tm = Functor Tm
```
-->

```agda
Nfs : Ty → Sem
Nfs τ .F₀   Γ   = el! (Nf Γ τ)
Nfs τ .F₁   ρ   = ren-nf ρ
Nfs τ .F-id     = ext (ren-nf-stop stop)
Nfs τ .F-∘  ρ σ = ext (ren-nf-∘ʳ ρ σ)

rnf : Nfs τ => Tm.₀ τ
rnf .η Γ σ            = ⟦ σ ⟧ₙ
rnf .is-natural x y f = ext (λ s → ren-⟦⟧ₙ f s)

Nes : Ty → Sem
Nes τ .F₀   Γ   = el! (Ne Γ τ)
Nes τ .F₁   ρ   = ren-ne ρ
Nes τ .F-id     = ext (ren-ne-stop stop)
Nes τ .F-∘  ρ σ = ext (ren-ne-∘ʳ ρ σ)

rne : Nes τ => Tm.₀ τ
rne .η Γ σ            = ⟦ σ ⟧ₛ
rne .is-natural x y f = ext (λ s → ren-⟦⟧ₛ f s)
```

</details>

Back from the case-bash trenches, the [[nerve]] of the embedding
$\thecat{Ren}_\Sigma$ is a functor into presheaves over renamings which
we write
$$\bf{Tm} : \thecat{Syn}_\Sigma \to \psh(\thecat{Ren}_\Sigma)$$,
which is Cartesian since both the aforementioned embedding and the
Yoneda embedding are, but it fails to be Cartesian closed, so we can not
appeal to initiality in the sameway. Moreover, just applying the
initiality trick wouldn't bring our `Nf`{.Agda} into the picture,
either. Even worse, *that's not how we stated the universal property of
$\thecat{Syn}_\Sigma$!*

```agda
open Cartesian-functor using (×-comparison-is-iso ; pres-terminal)

Tm-cartesian : Cartesian-functor Tm Free-cartesian PSh-cartesian
Tm-cartesian .×-comparison-is-iso a b = Sem.make-invertible
  (NT (elim! (λ a p q → p `, q)) λ x y f → ext λ p q → sym (Syn.⟨⟩∘ _))
  (ext (λ i a b → `π₁β ,ₚ `π₂β))
  (ext (λ i x → sym `πη))
Tm-cartesian .pres-terminal x .centre  = NT (λ _ _ → `!) (λ x y f → ext λ a → `!-η _)
Tm-cartesian .pres-terminal x .paths a = ext λ i x → `!-η _
```

However, there is an off-the-shelf solution we can reach for: since
$\psh(\thecat{Ren}_\Sigma)$ is *properly* Cartesian closed (it has
[[pullbacks]]), the [[Artin gluing]]
$$\thecat{Gl}_\Sigma = \psh(\thecat{Ren}_\Sigma)\downarrow\bf{Tm}$$
is a Cartesian closed category over the syntax, as required by the
universal property.

```agda
open Cat.Displayed.Instances.Gluing PSh-cartesian Free-cartesian Tm-cartesian
```

Surprisingly though, due to our definition of $\Lambda$-algebras having
base terms with arbitrary simple types as their domain, we're not quite
done putting together the induction. We would like to define the model
of $\Sigma$ in $\thecat{Gl}_\Sigma$ to have the base types interpreted
by normal forms (equivalently neutrals), but we have to know ahead of
time how to turn our interpretation of the other simple types into
neutrals.

# Normalisation algebras

To actually get normal forms out the other side, we will equip the
objects of $\thecat{Gl}_\Sigma$ over simple types $\tau$ with a
structure we refer to as a **normalisation algebra**. Recalling that an
object in $\thecat{Gl}_{\Sigma}(\tau)$ pairs a presheaf $P$ with a
natural transformation $⟦-⟧_P : P \To \bf{Tm}(\tau)$, a normalisation
algebra structure consists of further natural transformations
`reifies`{.Agda} from $P \To \operatorname{Nf}(\tau)$ and
`reflects`{.Agda} from $\operatorname{Ne}(\tau) \To P.$[^names]

[^names]:
    In the formalisation we reserve the *verbs* `reify`{.Agda} and
    `reflect`{.Agda} for the *components* of these transformations.

```agda
record Nfa {τ : Ty} (P : Gl ʻ τ) : Type ℓ where
  field
    reifies  : P .dom => Nfs τ
    reflects : Nes τ => P .dom
```

<!--
```agda
  ⟦_⟧ₚ : ∀ {Γ} → P .dom ʻ Γ → Mor ⟦ Γ ⟧ᶜ τ
  ⟦_⟧ₚ {Γ} x = P .map .η Γ x

  reify : ∀ {Γ} → P .dom ʻ Γ → Nf Γ τ
  reify = reifies .η _

  reflect : ∀ {Γ} → Ne Γ τ → P .dom ʻ Γ
  reflect = reflects .η _
  field
```
-->

These are required to make the following triangles commute.

::: mathpar

~~~{.quiver}
\[\begin{tikzcd}[ampersand replacement=\&]
  {\operatorname{Ne}(\tau)} \&\& {P(\tau)} \\
  \\
  \& {\bf{Tm}(\tau)}
  \arrow["{\rm{reflect}}", from=1-1, to=1-3]
  \arrow["{\rm{rne}}"', from=1-1, to=3-2]
  \arrow["{[\![-]\!]_P}", from=1-3, to=3-2]
\end{tikzcd}\]
~~~

~~~{.quiver}
\[\begin{tikzcd}[ampersand replacement=\&]
  {P(\tau)} \&\& {\rm{Nf}(\tau)} \\
  \\
  \& {\bf{Tm}(\tau)}
  \arrow["{\rm{reify}}", from=1-1, to=1-3]
  \arrow["{[\![-]\!]_P}"', from=1-1, to=3-2]
  \arrow["{\rm{rnf}}", from=1-3, to=3-2]
\end{tikzcd}\]
~~~

:::

```agda
    com₀ : {Γ : Cx} (n : Ne Γ τ)     → ⟦ reflect n ⟧ₚ ≡ ⟦ n ⟧ₛ
    com₁ : {Γ : Cx} (x : P .dom ʻ Γ) → ⟦ x ⟧ₚ ≡ ⟦ reify x ⟧ₙ
```

<!--
```agda
  reifyₙ : ∀ {Γ Δ} {ρ : Ren Γ Δ} {x : P .dom ʻ Δ} → reify (P .dom ⟪ ρ ⟫ x) ≡ ren-nf ρ (reify x)
  reifyₙ {Γ} {Δ} {ρ} {x} = reifies .is-natural Δ Γ ρ $ₚ x

  reflectₙ : ∀ {Γ Δ} {ρ : Ren Γ Δ} {x : Ne Δ τ} → reflect (ren-ne ρ x) ≡ P .dom ⟪ ρ ⟫ (reflect x)
  reflectₙ {Γ} {Δ} {ρ} {x} = reflects .is-natural Δ Γ ρ $ₚ x

open Cartesian-closed-over Gl Gl-cartesian {Free-closed} (Gl-closed PSh-closed Free-closed PSh-pullbacks) using ([_,_]')
open Nfa
```
-->

We start by building a normalisation algebra on the presheaf of normals,
which we take as the model of base types in $\thecat{Gl}_\Sigma$. This
is only *slightly* worse than trivial, because building the
`reflect`{.Agda} map--- embedding neutrals into normals--- is not
literally the identity function, but an inductive constructor instead.

```agda
Gl-base : (n : Node) → Gl ʻ (` n)
Gl-base x = cut (rnf {` x})

base-nfa : ∀ {x} → Nfa (Gl-base x)
base-nfa .reifies  = idnt
base-nfa .reflects = record where
  η          Γ x   = ne x
  is-natural Γ Δ ρ = ext λ a → refl
base-nfa .com₀ x = refl
base-nfa .com₁ x = refl
```

## Pairs

```agda
prod-nfa : ∀ {τ σ x y} → Nfa {τ} x → Nfa {σ} y → Nfa (x ×Gl y)
prod-nfa xnf ynf = record where
  module x = Nfa xnf
  module y = Nfa ynf
```

Next, we tackle products in $\thecat{Gl}_\Sigma$. Assume we already have
normalisation algebras on $X$ and $Y$. We can reify a pair into the
`pair`{.Agda} normal form, reifying each component in turn, and this
pairing preserves naturality.

```agda
  reifies  = record
    { η          = λ Γ (a , b) → pair (x.reify a) (y.reify b)
    ; is-natural = λ Γ Δ ρ     → ext (λ a b → ap₂ pair x.reifyₙ y.reifyₙ)
    }
```

Conversely, we reflect a neutral into a pair by reflecting each
*projection*, first wrapping them in the constructors `fstₙ`{.Agda} and
`sndₙ`{.Agda} to get something in the right type. Again, these
constructions preserve naturality.

```agda
  reflects = Sem.⟨
      NT (λ Γ x → x.reflect (fstₙ x)) (λ x y f → ext λ a → x.reflectₙ)
    , NT (λ Γ x → y.reflect (sndₙ x)) (λ x y f → ext λ a → y.reflectₙ)
    ⟩
```

Finally, we must commute those triangles. One is a straightforward
calculation and the other is a trivial invocation of the corresponding
triangle for the normalisation algebras we assumed.

```agda
  com₀ x =
    x.⟦ x.reflect (fstₙ x) ⟧ₚ `, y.⟦ y.reflect (sndₙ x) ⟧ₚ ≡⟨ ap₂ _`,_ (x.com₀ _) (y.com₀ _) ⟩
    `π₁ `∘ ⟦ x ⟧ₛ `, `π₂ `∘ ⟦ x ⟧ₛ                         ≡˘⟨ Syn.⟨⟩∘ _ ⟩
    (`π₁ `, `π₂) `∘ ⟦ x ⟧ₛ                                 ≡⟨ Syn.eliml (ap₂ _`,_ (sym `idr) (sym `idr) ∙ sym `πη) ⟩
    ⟦ x ⟧ₛ                                                 ∎

  com₁ (a , b) = ap₂ _`,_ (x.com₁ _) (y.com₁ _)
```

### Functions

```agda
arrow-nfa : ∀ {τ σ x y} → Nfa {τ} x → Nfa {σ} y → Nfa [ x , y ]'
arrow-nfa {x = x} {y = y} xnf ynf = arr where
  module x = Nfa xnf
  module y = Nfa ynf
```

Next come function types, which are trickier but still possible.

```agda
  arr : Nfa [ x , y ]'
  arr .reifies   = record
    { η          = λ Γ (_ , f , _) → lam (y.reify (f .η _ (drop stop , (x.reflect (var stop)))))
    ; is-natural = λ Γ Δ ρ → ext λ x y p → ap Nf.lam
      (ap y.reify (ap (λ e → y .η _ e) (ap drop (sym (∘ʳ-idr ρ)) ,ₚ x.reflectₙ)
      ∙ (y .is-natural (Γ , _) (Δ , _) (keep ρ) ·ₚ (drop stop , _)))
      ∙ y.reifyₙ)
    }

  arr .reflects = record
    { η          = λ Γ x →
        ⟦ x ⟧ₛ
      , NT (λ Δ (ρ , s) → y.reflect (app (ren-ne ρ x) (x.reify s)))
           (λ Δ Θ ρ → ext λ σ s → ap y.reflect (ap₂ Ne.app (ren-ne-∘ʳ ρ σ x) x.reifyₙ) ∙ y.reflectₙ)
      , ext λ Γ ρ s → sym (y.com₀ _ ∙ ap₂ (λ a b → `ev `∘ (a `, b)) (ren-⟦⟧ₛ ρ x) (sym (x.com₁ _)))
    ; is-natural = λ Γ Δ ρ → ext (λ n → Σ-pathp (ren-⟦⟧ₛ ρ n) (Σ-prop-pathp! (ext (λ Θ σ s → ap y.reflect (ap₂ app (sym (ren-ne-∘ʳ σ ρ n)) refl)))))
    }

  arr .com₀ f = refl
  arr .com₁ (φ , f , α) = sym $
    `ƛ ⟦ y.reify (f .η _ (drop stop , x.reflect (var stop))) ⟧ₙ  ≡⟨ ap `ƛ (sym (y.com₁ _) ∙ sym (unext α _ _ _)) ⟩
    `ƛ (`ev `∘ (φ `∘ `id `∘ `π₁ `, x.⟦ x.reflect (var stop) ⟧ₚ)) ≡⟨ ap `ƛ (ap₂ (λ a b → `ev `∘ (a `, b)) (ap (φ `∘_) `idl) (x.com₀ _ ∙ sym `idl)) ⟩
    `ƛ (`ev `∘ (φ `∘ `π₁ `, `id `∘ `π₂))                         ≡⟨ sym `ƛη ⟩
    φ                                                            ∎
```

# Normalisation by evaluation

<!--
```agda
module _ where
  open
    elim Gl-cartesian
      (Gl-closed PSh-closed Free-closed PSh-pullbacks)
      Gl-base
    renaming (Ty-elim to Ty-nf)
```
-->

We're finally ready to construct a section of $\thecat{Gl}_\Sigma$.
First, we build a normalisation algebra on the denotation of every
simple type, by a straightforward recursive argument using the cases
above--- while the case for the unit type was too simple to get a name.

```agda
  normalisation : ∀ τ → Nfa {τ} (Ty-nf τ)
  normalisation (` x)    = base-nfa
  normalisation (τ `× σ) = prod-nfa  (normalisation τ) (normalisation σ)
  normalisation (τ `⇒ σ) = arrow-nfa (normalisation τ) (normalisation σ)
  normalisation `⊤       = record
    { reifies  = NT (λ Γ _ → unit) (λ Γ Δ ρ → refl)
    ; reflects = Sem.!
    ; com₀     = λ _ → `!-η _
    ; com₁     = λ _ → refl
    }
```

This lets us model the base *terms* in $\thecat{Gl}_\Sigma$, which is
possible because (by construction) every base term $e : \tau \to y \in
\Sigma$ induces a natural transformation $\operatorname{Nf}(\tau) \To
\operatorname{Nf}(y)$, which is componentwise the constructor
`hom`{.Agda}, and we've constructed natural transformations
$\sem{tau} \To \operatorname{Nf}(\tau)$ from the interpretation of a
simple type into neutrals, namely `reifies`{.Agda}.

```agda
  private
    terms
      : ∀ {x : Ty} {y : Node} (e : Edge x y)
      → Gl.Hom[ (` e) ] (Ty-nf x) (Gl-base y)
    terms {x = x} {y = y} e .map =
          NT (λ Γ x → ne (hom e x)) (λ x y f → refl)
      ∘nt Nfa.reifies (normalisation x)

    terms {x = x} {y = y} e .com = ext λ Γ ρ →
      ap ((` e) `∘_) (sym (Nfa.com₁ (normalisation x) _))
```

We thus have a section of `Gl`{.Agda}, which performs `Normalisation`{.Agda}.

```agda
  Normalisation : Section Gl
  Normalisation = Free-ccc-elim terms
```

<!--
```agda
open Section Normalisation renaming (S₁ to ⟦_⟧₁)
```
-->

Let's see how to use this to actually normalise an element $e$ of
`Mor`{.Agda}. First, the section of `Gl`{.Agda} turns $e :
\operatorname{Mor}(x,y)$ into a natural transformation $\sem{e} :
\sem{x} \To \sem{y}$. To get an element of $\sem{x}$, we can pick the
context $x : \tau$ and `reflect`{.Agda} the zeroth variable; and from
the resulting element of $\sem{y}$, we can `reify`{.Agda} a normal form
$$
x : \tau \vdash_{nf} \operatorname{reify}(\sem{e}(\operatorname{reflect}(x))) : \sigma
$$
which is exactly what we wanted! We're finally `done`{.Agda}.

```agda
nf
  : ∀ {x y : Ty} (e : Mor x y)
  → Σ[ n ∈ Nf (∅ , x) y ] e ≡ ⟦ n ⟧ₙ `∘ (`! `, `id)
nf {x} {y} e = record { fst = done ; snd = sym beta } where
  module x = Nfa (normalisation x)
  module y = Nfa (normalisation y)

  done = y.reify (⟦ e ⟧₁ .map .η (∅ , x) (x.reflect (var stop)))
```

To show that the denotation of this normal form is the map we started
with, up to a trivial isomorphism between the context $x : \tau$ and the
type $\tau$, we can calculate with the definition of morphisms in
$\thecat{Gl}_\Sigma$ and the two triangles for the normalisation
algebras on the domain and codomain, one each.

```agda
  abstract
    sq : ⟦ done ⟧ₙ ≡ e `∘ `π₂
    sq =
      ⟦ done ⟧ₙ                                            ≡⟨ sym (y.com₁ _) ⟩
      y.⟦ ⟦ e ⟧₁ .map .η (∅ , x) (x.reflect (var stop)) ⟧ₚ ≡⟨ unext (⟦ e ⟧₁ .com) _ _ ⟩
      e `∘ x.⟦ x.reflect (var stop) ⟧ₚ                     ≡⟨ ap (e `∘_) (x.com₀ _) ⟩
      e `∘ `π₂                                             ∎

    beta : ⟦ done ⟧ₙ `∘ (`! `, `id) ≡ e
    beta = Syn.pushl sq ∙ Syn.elimr `π₂β
```

Because we went out of our way to get a universal property for the
syntax which computes nicely, we can play around with the normalisation
function, as long as all the types are (Agda) normal forms. For example,
the normal form of the identity function on pairs is the `pair`{.Agda}
of the `fstₙ`{.Agda} and `sndₙ`{.Agda} projections of the input
"variable", which are both neutral.

```agda
module _ (A : Node) where
  _ : nf {x = (` A) `× (` A)} {y = (` A) `× (` A)} `id .fst
    ≡ pair (ne (fstₙ (var stop))) (ne (sndₙ (var stop)))
  _ = refl
```

Since normal forms are all unquotiented, first-order data, we can decide
their equality. And since every morphism is the denotation of some
normal form, we can decide equality in `Mor`{.Agda}, too.

```agda
instance
  Discrete-Mor
    : ∀ ⦃ _ : Discrete Node ⦄
    → ⦃ _ : ∀ {x y} → Discrete (Edge x y) ⦄
    → ∀ {τ σ} → Discrete (Mor τ σ)
  Discrete-Mor .decide x y with fn ← nf
    with ((x' , p) , p') ← inspect (fn x)
       | ((y' , q) , q') ← inspect (fn y)
       | x' ≡? y'
  ... | yes x'=y' = yes (p ∙∙ ap (λ e → ⟦ e ⟧ₙ `∘ (`! `, `id)) x'=y' ∙∙ sym q)
  ... | no  x'≠y' = no λ x=y → x'≠y' $
       ap fst (sym p')
    ∙∙ ap (λ e → fst (fn e)) x=y
    ∙∙ ap fst q'
```
