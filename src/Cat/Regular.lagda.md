<!--
```agda
open import Cat.Diagram.Coequaliser.RegularEpi
open import Cat.Morphism.Factorisation
open import Cat.Diagram.Limit.Finite
open import Cat.Diagram.Coequaliser
open import Cat.Morphism.Strong.Epi
open import Cat.Diagram.Pullback
open import Cat.Diagram.Product
open import Cat.Prelude

import Cat.Reasoning as Cr
```
-->

```agda
module Cat.Regular where
```

# Regular categories {defines="regular-category"}

A **regular category** is a category with [[pullback]]-stable [[image
factorisations]]. To define regular categories, we use the theory of
[orthogonal morphisms], specifically [strong epimorphisms]: A regular
category is one where every morphism factors as a strong epimorphism
followed by a monomorphism, and strong epimorphisms are stable under
pullback.

[image]: Cat.Diagram.Image.html
[regular epi]: Cat.Diagram.Coequaliser.RegularEpi.html
[orthogonal morphisms]: Cat.Morphism.Orthogonal.html
[strong epimorphisms]: Cat.Morphism.Strong.Epi.html

At face value, it's a bit weird to take the definition of regular
categories to talk about strong, rather than _regular_, epimorphisms.
But it turns out that strong epimorphisms correspond pretty directly to
the idea of an image factorisation, or at least much _more_ directly
than regular epimorphisms do. As we shall see, in a regular category,
every strong epimorphism is regular.

<!--
```agda
open Functor

module _ {o ‚Ñì} (ùíû : Precategory o ‚Ñì) where
  private module C = Cr ùíû

  StrongEpi : ‚àÄ {a b} ‚Üí C.Hom a b ‚Üí Œ©
  StrongEpi x = elŒ© (is-strong-epi ùíû x)

  Mono : ‚àÄ {a b} ‚Üí C.Hom a b ‚Üí Œ©
  Mono x = elŒ© (C.is-monic x)
```
-->

```agda
  record is-regular : Type (o ‚äî ‚Ñì) where
    field
      factor : ‚àÄ {a b} (f : C.Hom a b) ‚Üí Factorisation ùíû StrongEpi Mono f
      stable : is-pullback-stable ùíû (is-strong-epi ùíû)
      has-is-lex : Finitely-complete ùíû

    module factor {a b} (f : C.Hom a b) = Factorisation (factor f)
    module lex = Finitely-complete has-is-lex
```

We also introduce some more palatable names for the components of the
provided factorisations: Letting $f : A \to B$ be a map and $A \epi X
\mono B$ its image factorisation, we refer to $X$ as $\im(f)$, to $A
\epi X$ as `a‚Ü†im[_]`{.Agda}, and $X \mono B$ as `im[_]‚Ü™b`{.Agda}. These
latter two names have a placeholder for the morphism we are factoring.

```agda
    im[_] : ‚àÄ {a b} (f : C.Hom a b) ‚Üí C.Ob
    im[ f ] = factor f .Factorisation.mediating

    im[_]‚Ü™b : ‚àÄ {a b} (f : C.Hom a b) ‚Üí im[ f ] C.‚Ü™ b
    im[ f ]‚Ü™b = record { monic = ‚ñ°-out! (factor f .Factorisation.forget‚ààM) }

    a‚Ü†im[_] : ‚àÄ {a b} (f : C.Hom a b) ‚Üí C.Hom a im[ f ]
    a‚Ü†im[ f ] = factor f .Factorisation.mediate
```

<!--
```agda
  module _ (r : is-regular) where
    private module r = is-regular r
    open C

    mono‚Üíim-iso
      : ‚àÄ {a b} (f : C.Hom a b)
      ‚Üí C.is-monic f
      ‚Üí C.is-invertible r.a‚Ü†im[ f ]
    mono‚Üíim-iso f x = res where
      open Factorisation
      rem‚ÇÅ : f ‚â° r.im[ f ]‚Ü™b .C.mor C.‚àò r.a‚Ü†im[ f ]
      rem‚ÇÅ = r.factor f .factors

      p = ‚ñ°-out! (r.factor f .mediate‚ààE) .snd (record { monic = x })
        (sym (r.factor f .factors) ‚àô sym (C.idr _))
      res = C.make-invertible (p .centre .fst)
        (‚ñ°-out! (r.factor f .mediate‚ààE) .fst _ _
          (C.pullr (p .centre .snd .fst) ‚àô C.id-comm))
        (p .centre .snd .fst)
```
-->

## Motivation

Regular categories are interesting in the study of categorical logic
since they have exactly the structure required for their [subobject
fibrations] to interpret existential quantifiers, _and_ for these to
commute with substitution which, in this case, is interpreted as
pullback.

[subobject fibrations]: Cat.Displayed.Instances.Subobjects.html

We've already seen that, in a category with pullbacks, arbitrary
morphisms $f : a \to b$ induce [an adjunction] $f_! \dashv f^*$ between
$\cC/b \adj \cC/a$: the right adjoint models the substitution (base
change) along $f$, and the [[left adjoint]] models the _dependent sum_ over
$f$. Between subobject categories, though, pullbacks are not enough
structure: this can be seen type-theoretically by noting that, even if
$P : A \to \Omega$ is a family of propositions, the sum $\Sigma_(x : A)
P(x)$ will generally not be.

[an adjunction]: Cat.Functor.Pullback.html

Instead, the existential quantifier must be _truncated_ to work
correctly, and it is this truncation that the pullback-stable image
factorisations in a regular category exist to model. In a category with
pullbacks and images, we have adjunctions $\exists_f \dashv f^*$, now
between $\Sub(a) \adj \Sub(b)$. However, the existence of images is not
enough to guarantee they behave type-theoretically. In a regular
category, since images are stable under pullback, the equation

$$
\exists_k h^*\phi \cong f^* \exists_g \phi
$$,

holds as long as $f$, $g$, $h$ and $k$ fit into a pullback square,
expressing that existential quantification commutes with substitution.

Another reason to be interested in regular categories is their
well-behaved calculus of [relations]: any category with pullbacks has an
associated [bicategory of spans], but images are precisely what's
missing to interpret composition _of relations_. Indeed, the existential
quantifier in a regular category allows us to interpret the formula for
relational composition,

[relations]: Cat.Bi.Instances.Relations.html
[bicategory of spans]: Cat.Bi.Instances.Spans.html

$$
(R \circ S)(a, b) = \exists_{c : C} R(a, c) \land R(c, s)
$$,

internally to an arbitrary category. Regularity comes in when we want to
show that composition of relations is _associative_: indeed,
associativity in the formula above, modulo associativity of the
conjunction $A \land B$, is exactly a question of _commutativity between
$\exists$ and substitution_. It follows, but we do not establish here,
that a category is regular _exactly when_ its composition of relations
is associative.

As a universe for interpreting logic, regular categories allow us to
talk about formulae (in arbitrary contexts) consisting of conjunction,
equality, truth, and existential quantification, and all of these
connectives commute with substitution. This subset of logic is,
unsurprisingly, called **regular logic**. For working with regular
categories, one notes that [$\Sets$ is regular], and that [regularity is
preserved by slicing].

[$\Sets$ is regular]: Cat.Regular.Instances.Sets.html
[regularity is preserved by slicing]: Cat.Regular.Slice.html

## Strong epis are regular

This section formalises the proof of A1.3.4 from [@Elephant], which says
that every strong epimorphism^[Note: Johnstone prefers to work with
"covers" instead, which in our lingo are _extremal_ epimorphisms. In a
[[finitely complete]] category, strong and extremal epimorphisms coincide]
in a regular category is regular. Actually, we'll show that every strong
epimorphism in a regular category is **effective**: it's the coequaliser
of its kernel pair.

```agda
  -- Johnstone, A.1.3.4
  module _ (r : is-regular) {A B} (f : C.Hom A B) (is-s : is-strong-epi ùíû f) where
    private
      module r = is-regular r
      module kp = Pullback (r.lex.pullbacks f f)
        renaming (apex to R ; p‚ÇÅ to a ; p‚ÇÇ to b)
```

<!--
```agda
      open kp using (R ; a ; b ; square)
      open Binary-products ùíû r.lex.products
      open C
```
-->

For a strong epimorphism $f : A \epi B$, start by pulling $f$ back along
itself to form the kernel pair $(a, b) : R \tto A$. We want to show that
$f$ coequalises $a$ and $b$, which means that any morphism $c : A \to C$
satisfying $ca = cb$ should have a unique factorisation through $f$. So,
quantify over such morphisms and let's get started.

```agda
    private module Make {C} {c : C.Hom A C} (w : c C.‚àò a ‚â° c C.‚àò b) where
```

We start by calculating the image factorisation of $(f,c) : A \to B
\times C$,

$$
A \xepi{d} D \xmono {(g, h)} B \times C
$$.


```agda
      dgh : Factorisation ùíû StrongEpi Mono ‚ü® f , c ‚ü©
      dgh = r.factor ‚ü® f , c ‚ü©
      module dgh = Factorisation dgh
        renaming (mediating to D ; forget to gh ; mediate to d)
      open dgh using (D ; d ; gh)

      g : C.Hom D B
      g = œÄ‚ÇÅ C.‚àò gh

      h : C.Hom D C
      h = œÄ‚ÇÇ C.‚àò gh
```

Following Johnstone, we show that $g$ is an isomorphism, so that
$hg\inv$ is the factorisation we're looking for.^[Johnstone says it's
_clearly_ unique, but the tiny calculation is included at the end of the
proof since it wasn't clear to me] Since $f$ is an extremal epimorphism,
any monomorphism through which it factors must be an iso. And since we have

$$
f = \pi_1(f,c) = \pi_1(g,h)d = gd
$$,

it will suffice to show that $g$ is a monomorphism. So assume you're
given $k, l : E \to D$ with $gk = gl$; Let's show that $k = l$. Start by
pulling back $(k,l) : E \to D \times D$ along $d \times d : A \times A$,
obtaining

~~~{.quiver}
\[\begin{tikzcd}
  P && E \\
  \\
  {A\times A} && {D\times D}
  \arrow["p", from=1-1, to=1-3]
  \arrow["{(m,n)}"', from=1-1, to=3-1]
  \arrow["{d\times d}"', from=3-1, to=3-3]
  \arrow["{(k,l)}", from=1-3, to=3-3]
  \arrow["\lrcorner"{anchor=center, pos=0.125}, draw=none, from=1-1, to=3-3]
\end{tikzcd}\]
~~~

```agda
      g-monic : C.is-monic g
      g-monic {e} k l w' = ‚ñ°-out! dgh.forget‚ààM _ _ rem‚Çà where
        d√ód = √ó-functor .F‚ÇÅ (d , d)
        module pb = Pullback (r.lex.pullbacks ‚ü® k , l ‚ü© d√ód)
          renaming (p‚ÇÅ to p ; apex to P ; p‚ÇÇ to mn ; square to sq'-)
        open pb using (p ; P ; mn ; sq'-)
        m = œÄ‚ÇÅ C.‚àò mn
        n = œÄ‚ÇÇ C.‚àò mn
        sq' : ‚ü® k C.‚àò p , l C.‚àò p ‚ü© ‚â° ‚ü® d C.‚àò m , d C.‚àò n ‚ü©
        sq' = sym (‚ü®‚ü©‚àò _) ‚àô sq'- ‚àô ‚ü®‚ü©-unique (C.pulll œÄ‚ÇÅ‚àò‚ü®‚ü© ‚àô C.pullr refl)
                                             (C.pulll œÄ‚ÇÇ‚àò‚ü®‚ü© ‚àô C.pullr refl)
```

We define a map $q : P \to R$ into the kernel pair of $a$, factoring
$(m,n)$ through $(a,b)$. Using this morphism we may conclude that $hkp =
hlp$ (`rem‚ÇÅ`{.Agda}).

```agda
        q : C.Hom P R
        q = kp.universal $
          f ‚àò m         ‚â°‚ü® C.pushl (extend-œÄ‚ÇÅ dgh.factors ‚àô C.pulll refl) ‚ü©
          g ‚àò d ‚àò m     ‚â°Àò‚ü® refl‚ü©‚àò‚ü® by-œÄ‚ÇÅ sq' ‚ü©
          g ‚àò k ‚àò p     ‚â°‚ü® C.extendl w' ‚ü©
          g ‚àò l ‚àò p     ‚â°‚ü® refl‚ü©‚àò‚ü® by-œÄ‚ÇÇ sq' ‚ü©
          g ‚àò d ‚àò n     ‚â°Àò‚ü® C.pushl (extend-œÄ‚ÇÅ dgh.factors ‚àô C.pulll refl) ‚ü©
          f ‚àò n         ‚àé

        rem‚ÇÅ = h ‚àò k ‚àò p     ‚â°‚ü® refl‚ü©‚àò‚ü® by-œÄ‚ÇÅ sq' ‚ü©
               h ‚àò d ‚àò m     ‚â°‚ü® pulll (pullr (sym dgh.factors) ‚àô œÄ‚ÇÇ‚àò‚ü®‚ü©) ‚ü©
               c ‚àò m         ‚â°Àò‚ü® refl‚ü©‚àò‚ü® kp.p‚ÇÅ‚àòuniversal ‚ü©
               c ‚àò a ‚àò q     ‚â°‚ü® extendl w ‚ü©
               c ‚àò b ‚àò q     ‚â°‚ü® refl‚ü©‚àò‚ü® kp.p‚ÇÇ‚àòuniversal ‚ü©
               c ‚àò n         ‚â°Àò‚ü® pulll (pullr (sym dgh.factors) ‚àô œÄ‚ÇÇ‚àò‚ü®‚ü©) ‚ü©
               h ‚àò d ‚àò n     ‚â°Àò‚ü® refl‚ü©‚àò‚ü® by-œÄ‚ÇÇ sq' ‚ü©
               h ‚àò l ‚àò p     ‚àé
```

We want to show that $hl = hk$, for which it will suffice for $p$ to be
an epimorphism. Since we're working in a regular category, we can show
that $p$ is a _strong_ epimorphism by showing that $d \times d$ is a
composite of strong epis. But $d \times d$ is the composite $(d \times
\id)(\id \times d)$, and both of those maps are pullbacks of
$d$, which _is_ a strong epimorphism since it arises from an image
factorisation.

<details>
<summary>This `<details>`{.html} tag contains the proof that $d \times
1$ and $1 \times d$ are pullbacks of $d$. You may choose to unfold or
skip it.
</summary>

```agda
        open is-pullback

        rem‚ÇÇ : is-strong-epi ùíû (√ó-functor .F‚ÇÅ (d , id))
        rem‚ÇÇ = r.stable d œÄ‚ÇÅ {p2 = œÄ‚ÇÅ} (‚ñ°-out! dgh.mediate‚ààE) Œª where
          .square ‚Üí œÄ‚ÇÅ‚àò‚ü®‚ü©
          .universal {p‚ÇÅ' = p‚ÇÅ'} {p‚ÇÇ'} p ‚Üí ‚ü® p‚ÇÇ' , œÄ‚ÇÇ ‚àò p‚ÇÅ' ‚ü©
          .p‚ÇÅ‚àòuniversal {p‚ÇÅ' = p‚ÇÅ'} {p‚ÇÇ'} {p = p} ‚Üí ‚ü®‚ü©‚àò _
            ¬∑¬∑ ap‚ÇÇ ‚ü®_,_‚ü© (pullr œÄ‚ÇÅ‚àò‚ü®‚ü© ‚àô sym p) (pullr œÄ‚ÇÇ‚àò‚ü®‚ü© ‚àô idl _)
            ¬∑¬∑ sym (‚ü®‚ü©-unique refl refl)
          .p‚ÇÇ‚àòuniversal ‚Üí œÄ‚ÇÅ‚àò‚ü®‚ü©
          .unique {p = p} {lim'} q r ‚Üí ‚ü®‚ü©-unique r $ sym $
            ap (œÄ‚ÇÇ ‚àò_) (sym q) ‚àô pulll œÄ‚ÇÇ‚àò‚ü®‚ü© ‚àô ap (_‚àò lim') (idl _)

        rem‚ÇÉ : is-strong-epi ùíû (√ó-functor .F‚ÇÅ (id , d))
        rem‚ÇÉ = r.stable d œÄ‚ÇÇ {p2 = œÄ‚ÇÇ} (‚ñ°-out! dgh.mediate‚ààE) Œª where
          .square ‚Üí œÄ‚ÇÇ‚àò‚ü®‚ü©
          .universal {p‚ÇÅ' = p‚ÇÅ'} {p‚ÇÇ'} p ‚Üí ‚ü® œÄ‚ÇÅ ‚àò p‚ÇÅ' , p‚ÇÇ' ‚ü©
          .p‚ÇÅ‚àòuniversal {p = p} ‚Üí ‚ü®‚ü©‚àò _
            ¬∑¬∑ ap‚ÇÇ ‚ü®_,_‚ü© (pullr œÄ‚ÇÅ‚àò‚ü®‚ü© ‚àô idl _) (pullr œÄ‚ÇÇ‚àò‚ü®‚ü©)
            ¬∑¬∑ sym (‚ü®‚ü©-unique refl p)
          .p‚ÇÇ‚àòuniversal ‚Üí œÄ‚ÇÇ‚àò‚ü®‚ü©
          .unique {p = p} {lim'} q r ‚Üí ‚ü®‚ü©-unique
            (sym (ap (œÄ‚ÇÅ ‚àò_) (sym q) ‚àô pulll œÄ‚ÇÅ‚àò‚ü®‚ü© ‚àô ap (_‚àò lim') (idl _)))
            r

        rem‚ÇÑ = sym (√ó-functor .F-‚àò _ _)
             ‚àô ap (√ó-functor .F‚ÇÅ) (Œ£-pathp (idl _) (idr _))
```
</details>

So $d \times d$ is a strong epimorphism by the above remarks, and $p$ is
a pullback of $d \times d$, so it is also strong epic (`rem‚ÇÜ`{.Agda});
We obtain $hk = hl$ (`rem‚Çá`{.Agda}). By pushing some symbols, this gives
$(g,h)k = (g,h)l$ (`rem‚Çà`{.Agda}), but $(g,h)$ is a monomorphism by
construction, so $k = l$ --- so $g$ is _also_ monic.

```agda
        rem‚ÇÖ : is-strong-epi ùíû d√ód
        rem‚ÇÖ = subst-is-strong-epi ùíû rem‚ÇÑ (strong-epi-‚àò ùíû _ _ rem‚ÇÉ rem‚ÇÇ)

        rem‚ÇÜ : is-strong-epi ùíû p
        rem‚ÇÜ = r.stable _ _ rem‚ÇÖ pb.has-is-pb

        rem‚Çá : h ‚àò k ‚â° h ‚àò l
        rem‚Çá = rem‚ÇÜ .fst _ _ $
          (h ‚àò k) ‚àò p   ‚â°‚ü® sym (assoc _ _ _) ‚àô rem‚ÇÅ ‚ü©
          h ‚àò l ‚àò p     ‚â°‚ü® pulll refl ‚ü©
          (h ‚àò l) ‚àò p   ‚àé

        rem‚Çà : gh C.‚àò k ‚â° gh C.‚àò l
        rem‚Çà =
          gh ‚àò k              ‚â°‚ü® ‚ü®‚ü©-unique refl refl ‚ü©‚àò‚ü®refl ‚ü©
          ‚ü® g , h ‚ü© ‚àò k       ‚â°‚ü® ‚ü®‚ü©‚àò _ ‚ü©
          ‚ü® g ‚àò k , h ‚àò k ‚ü©   ‚â°‚ü® ap‚ÇÇ ‚ü®_,_‚ü© w' rem‚Çá ‚ü©
          ‚ü® g ‚àò l , h ‚àò l ‚ü©   ‚â°Àò‚ü® ‚ü®‚ü©‚àò _ ‚ü©
          ‚ü® g , h ‚ü© ‚àò l       ‚â°Àò‚ü® ‚ü®‚ü©-unique refl refl ‚ü©‚àò‚ü®refl ‚ü©
          gh ‚àò l              ‚àé
```

Having shown that $g$ is monic, and knowing that $f$ --- a strong (thus
extremal) epimorphism --- factors through it, we conclude that $g$ is an
isomorphism. It remains to `compute`{.Agda} that $hg\inv f = c$, which
we do below.

<!--
```agda
      g-iso : is-invertible g
      g-iso = make-invertible (p .centre .fst) (p .centre .snd .snd)
        (‚ñ°-out! dgh.mediate‚ààE .fst _ _
          ( pullr (pullr (sym dgh.factors) ‚àô œÄ‚ÇÅ‚àò‚ü®‚ü©)
          ‚àô p .centre .snd .fst ‚àô introl refl))
        module g-ortho where
          p = is-s .snd (record { monic = g-monic })
            (idl _ ‚àô sym (pullr (sym dgh.factors) ‚àô œÄ‚ÇÅ‚àò‚ü®‚ü©))
      module g = _‚âÖ_ (invertible‚Üíiso _ g-iso)
```
-->

```agda
      compute =
        (h ‚àò g.from) ‚àò f                           ‚â°‚ü® pullr refl ‚àô pullr refl ‚ü©
        œÄ‚ÇÇ ‚àò dgh.gh ‚àò g.from ‚àò f                   ‚â°‚ü® refl ‚ü©‚àò‚ü® ‚ü®‚ü©-unique refl refl ‚ü©‚àò‚ü® refl ‚ü©
        œÄ‚ÇÇ ‚àò ‚ü® g , h ‚ü© ‚àò g.from ‚àò f                ‚â°‚ü® refl‚ü©‚àò‚ü® ‚ü®‚ü©‚àò _ ‚ü©
        œÄ‚ÇÇ ‚àò ‚ü® g ‚àò g.from ‚àò f , h ‚àò g.from ‚àò f ‚ü©   ‚â°‚ü® œÄ‚ÇÇ‚àò‚ü®‚ü© ‚ü©
        h ‚àò g.from ‚àò f                             ‚â°‚ü® refl‚ü©‚àò‚ü® g-ortho.p .centre .snd .fst ‚ü©
        h ‚àò dgh.d                                  ‚â°‚ü® pullr (sym dgh.factors) ‚ü©
        œÄ‚ÇÇ ‚àò ‚ü® f , c ‚ü©                             ‚â°‚ü® œÄ‚ÇÇ‚àò‚ü®‚ü© ‚ü©
        c                                          ‚àé
```

This proves that $f$, an arbitrary strong epi, coequalises its kernel
pair. It's an effective epimorphism! So it's definitely the case that it
coequalises _some_ pair of maps.


```agda
    open is-regular-epi renaming (r to Kp)
    open is-coequaliser
    is-strong-epi‚Üíis-regular-epi : is-regular-epi ùíû f
    is-strong-epi‚Üíis-regular-epi = go where
      go : is-regular-epi ùíû f
      go .Kp = kp.R
      go .arr‚ÇÅ = kp.a
      go .arr‚ÇÇ = kp.b
      go .has-is-coeq .coequal = kp.square
      go .has-is-coeq .universal w = Make.h w ‚àò Make.g.from w
      go .has-is-coeq .factors {e' = e'} {p = w} = Make.compute w
      go .has-is-coeq .unique {e' = e'} {p = p} {colim} q = is-s .fst _ _ $
        colim ‚àò f                      ‚â°‚ü® q ‚ü©
        e'                             ‚â°Àò‚ü® Make.compute p ‚ü©
        (Make.h p ‚àò Make.g.from p) ‚àò f ‚àé
```
